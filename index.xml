<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tobin Harding</title>
    <link>/index.xml</link>
    <description>Recent content on Tobin Harding</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 05 Dec 2017 16:01:57 +1100</lastBuildDate>
    <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Software Apprenticeship</title>
      <link>/blog/apprenticeship/</link>
      <pubDate>Tue, 05 Dec 2017 16:01:57 +1100</pubDate>
      
      <guid>/blog/apprenticeship/</guid>
      <description>

&lt;p&gt;In 2015 I had the very fortunate opportunity to invest some time in my skill as
a programmer. At this time I had an undergraduate degree (Bachelor of Science)
double majoring in software and computer networks. I had also completed the
first two thirds of a masters degree, also in computer science. I chose not to
complete the thesis because I felt I did not have anything to add to the field,
graduating with a diploma of Computer Science (pass with high distinction). It
was during this decision that I became acutely aware of my lack of programming
ability.&lt;/p&gt;

&lt;p&gt;I picked up Kernighan and Ritchie [KnR12] and started from scratch. Herein
started a two year apprenticeship of software development.&lt;/p&gt;

&lt;p&gt;Why an &amp;lsquo;apprenticeship&amp;rsquo;? I did not start out with much of an idea of what I was
trying to achieve. I just knew that if I was going to get any good at this
programming business I needed more experience. My preferred style of learning is
book reading, and I had done plenty of this at uni. But it was also self evident
that you don&amp;rsquo;t learn to code by reading books. Well why not &lt;em&gt;actually&lt;/em&gt; do the
exercises. Then as long as I picked up the right books I would be assured
success, right?&lt;/p&gt;

&lt;p&gt;Over the next two years I would read the best part of 53 computer science text
books and complete the majority of the exercises in any that had them. During
this time I read a number of books and blog posts about software
craftsmanship. Say what you will about the movement the idea of an
apprenticeship struck a chord with me and I started to view what I was doing as
such. Text book authors were my masters and I was there to learn.&lt;/p&gt;

&lt;p&gt;This post is intended for three people.&lt;/p&gt;

&lt;p&gt;1) Software developers wishing to understand the path I chose.&lt;br /&gt;
2) Potential employers, wishing to understand my experience.&lt;br /&gt;
3) Family and friends, wishing to know what I was up to all that time locked
away.&lt;/p&gt;

&lt;p&gt;There are many ways to achieve ones goals mine is but one. Each individual is
different, we learn differently and we engage in different ways. I do not in
any way suggest that this is the best path. It is simply the path I chose.&lt;/p&gt;

&lt;h2 id=&#34;the-beginning&#34;&gt;The Beginning&lt;/h2&gt;

&lt;p&gt;As stated above the first text I pick up was KnR. To this day, in my opinion,
this is one of the best technical books ever written. If there is perfection in
printed text then KnR is it. My first obstacle was to be able to
concentrate for long periods of time doing mentally taxing work. At first if I
remember correctly I could only concentrate for a few hours each day. It was at
least three months before I could complete a full work day and I still remember
with glee my first 12 hour day.&lt;/p&gt;

&lt;p&gt;During this stage I committed to organize my time as if I was a remote
employee. I would endevour to work a &lt;em&gt;normal&lt;/em&gt; 40 work week and I would log work
session times and topics. (Though during some of the more obsessive phases I was coding
much more than this.) If you are interested the
&lt;a href=&#34;https://github.com/tcharding/work-logs&#34;&gt;logs&lt;/a&gt; are all online. At first I
started logging by hand. The logs from the start are incomplete. I believe that
I worked on KnR from May 2015 through July. During this time I also separated
from my wife. Be careful kids too much coding can effect your social life :)
During this time I also settled on a development environment. For the record the
stack I settled on is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Emacs, Zsh, Terminator, Mutt, Firefox, Git, and GCC.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the record I have used in the past Ubuntu, Debian, Slackware, and Arch. I
now use Ubuntu.&lt;/p&gt;

&lt;h2 id=&#34;unix-programming&#34;&gt;UNIX Programming&lt;/h2&gt;

&lt;p&gt;The week before I started undergrad, in a fit of enthusiasm, I went to the store
and bought a copy of Advance Programming in the UNIX Environment (APUE). This
was the 2nd edition. Prior to starting university my total computer experience
consisted of: A term writing logo in year 9. A month or two writing a text based
game in DOS and two months playing around on the internet (primarily on &amp;lsquo;hack
this site&amp;rsquo;). Oh and there was the time I deleted my Mums C: drive when I was a
kid.  Suffice to say I didn&amp;rsquo;t clock up any hours in front of the keyboard after
that. To say that APUE was a little advanced for me is an understatement. I
however had a number of attempts to read it over the years with varying levels
of success.&lt;/p&gt;

&lt;p&gt;In August I commenced work on APUE for real (I even bought the new 3rd edition
[SnR13]). In parallel I decided to work on another classic UNIX text, UNIX
Systems Programming (USP) [SFR04]. By this stage I was routinely working 12
hours a day stopping only for food breaks. I did this 4 days a week and played
with my kids the other 3 days. It appears, from the logs, that I also started to
read Knuth during this time. I included all reading in logged time as time
worked.&lt;/p&gt;

&lt;p&gt;On September 20 I picked up Learning Perl [RS11]. I clearly remember wanting to
have something else to work on to break up the C systems programming. At this
stage there were some low moments when things got rather arduous (SysV IPC I&amp;rsquo;m
talking to you). On the 2nd of October I completed APUE [SnR13]. Every chapter
and every exercise. I didn&amp;rsquo;t make it through the last section of USP [SFR04], I
can&amp;rsquo;t remember why. As soon as those two were finished and while still working
on Perl stuff (moved onto Intermediate Perl [RS12]) I started UNIX Network
Programming (UNP) [SFR04]. This is anther classic UNIX text, Stevens really is a
heavy weight in the field.&lt;/p&gt;

&lt;p&gt;October saw the end of Knuth volume 1 [Kn97v1]. It seems I started volume 2
[Kn97v2]. The logs don&amp;rsquo;t look like I finished it all in one go but I did finish
it. When I say finish I mean my eyes passed over all the words, how much of it
went in I cannot say :) Eventually I completed volume 2 and started volume 3. I
never did make it far into volume 3 though.&lt;/p&gt;

&lt;h2 id=&#34;security&#34;&gt;Security&lt;/h2&gt;

&lt;p&gt;My next focus would be security and cryptography. Here I made my first of two
attempts at the security programming challenges (previously called &amp;lsquo;Matasano&amp;rsquo;)
now online at &lt;a href=&#34;https://www.cryptopals.com/&#34;&gt;cryptopals&lt;/a&gt;. The first attempt was
using Perl. Wednesday the 20th October I completed UNP [SFR04]. I picked up
Schneier [BS15] and got cracking (no pun intended). By mid way through November
I came to the conclusion that Python would be better suited to the security
challenges and would also be a useful tool to have in my kit. I ordered Python
Essential Reference [DB09] and started work on
&lt;a href=&#34;https://www.learnpythonthehardway.org/&#34;&gt;Python the Hard Way&lt;/a&gt;. On the 23rd I
restarted the cryptopals challenges from scratch in Python.&lt;/p&gt;

&lt;p&gt;Enjoying the crypto challenges, in December, I started working in parallel on
the &lt;a href=&#34;http://eudyptula-challenge.org/&#34;&gt;Eudyptula Challenge&lt;/a&gt;. I also threw up a
few solutions on mathematical programming challenge site
&lt;a href=&#34;https://projecteuler.net/&#34;&gt;Project Euler&lt;/a&gt;. In December I read Version Control
with Git [LMC12] and Beginning Linux Programming [MnS09].&lt;/p&gt;

&lt;h2 id=&#34;open-source-contribution&#34;&gt;Open Source Contribution&lt;/h2&gt;

&lt;p&gt;January saw a loss of direction. I read a book on Web development [RS13],
continued cryptopals and made my first attempt at functional programming with
The Little Schemer [FnF96] and The Scheme Programming Language [KD09]. January
also hosted what turned out to be a pivotal text Clean Code [RM09] by Uncle
Bob. This book had a &lt;strong&gt;massive&lt;/strong&gt; effect on me and drives my software development
to this day. If I had to pick one book from the whole apprenticeship to define
as &lt;em&gt;essential&lt;/em&gt; this would be it. January also saw the start of my first ever
open source contributions. This was to the Open Bazaar Server project written
in Python.&lt;/p&gt;

&lt;p&gt;I spent a bit over a month solid working on Open Bazaar. Development was done
via GitHub and I learned a lot from the experience.&lt;/p&gt;

&lt;p&gt;Mid way through February I stopped working on Open Bazaar and commenced learning
Golang via The Go Programming Language [DnK16]. During March I also read up on
my shell of choice zsh in From Bash to Z Shell [KPS05]&lt;/p&gt;

&lt;p&gt;It was during the months around this time that I thought it a good idea to touch
up on my mathematics skill. I can&amp;rsquo;t say I was extremely successful (I measure
success by having completed a large portion of a text) but I did attempt
multiple texts from various branches of pure and applied mathematics and even
learned a thing or two. With similar brain developmental ideas in mind I
attempted to learn the violin. I practiced an hour a day for a few months
eventually giving up on the idea along with the math study.&lt;/p&gt;

&lt;h2 id=&#34;systems-programming&#34;&gt;Systems Programming&lt;/h2&gt;

&lt;p&gt;On the 12th of March something drove me to pick up The Linux Programming
Interface (TLPI) by Michael Kerrisk [MK10] and get back into systems programming
in C. I should mention here that an undercurrent driving me since January 2013
was a desire to be a Linux Kernel developer. This desire was born out of
attendance of the conference &lt;a href=&#34;https://linux.conf.au/&#34;&gt;LinuxConfAu&lt;/a&gt; in
Perth 2013. Since then I had hoped to become a competent enough programmer to
try my hand at Kernel development. More on this later. This explains my choice
to do more C coding even though the Kerrisk text is very similar in content to
APUE, amusingly it was SysV IPC that stopped me in this text also. I completed
every chapter and exercise up to, and including, chapter 44. Kerrisk is an
extremely competent writer and I agree with those who say that the mantle has
now passed from Stevens to Kerrisk when it comes to leaning systems programming
in the *nix environment.&lt;/p&gt;

&lt;p&gt;I continue working on TLPI until the end of April. Then over the next few months
I would read the following operating systems texts&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Modern Operating Systems [AT14]&lt;/li&gt;
&lt;li&gt;Linux Device Drivers 3rd Edition [CRK05]&lt;/li&gt;
&lt;li&gt;Essential Linux Device Drivers [SV08]&lt;/li&gt;
&lt;li&gt;Linux Kernel Development [RL10]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In May I would add ARM Assembly Language [WH09] to the list of completed texts
(including most but not all of the programming exercises).&lt;/p&gt;

&lt;h2 id=&#34;functional-programming&#34;&gt;Functional Programming&lt;/h2&gt;

&lt;p&gt;June 2016 would see the start of my second functional programming block. This
included re-reading The Little Schemer [FnF96] and re-working all the code. I
then started one of the highlights of the apprenticeship The Structure and
Interpretation of Computer Programs [ASS96]. This text needs no introduction
and for very good reason. I make no excuse when I say that this book was tough
going. The text is comprised of 5 chapters. I worked every exercise in the first
4 chapters. Chapter 5 implements an interpreter but by the end of chapter 4 I
was getting lost. I did not manage to complete chapter 5. During this phase I
used GNU Guile Scheme and got a small patch accepted into the project. The
patch was a fix to a known bug and removed an erroneous compiler warning that
was emitted every time the REPL started. The patch was in C and Scheme.&lt;/p&gt;

&lt;p&gt;August brought more functional programming with
&lt;a href=&#34;http://learnyouahaskell.com/&#34;&gt;Learn You a Haskell For Great Good&lt;/a&gt; and Real
World Haskell [SGS09] although I did not complete Real World Haskell. Functional
programming continued into September with work on
&lt;a href=&#34;https://wiki.haskell.org/99_questions&#34;&gt;Ninety-Nine Haskell Problems&lt;/a&gt; and
&lt;a href=&#34;http://www.seas.upenn.edu/~cis194/spring13/&#34;&gt;CIS194&lt;/a&gt;. It was during CIS194 that
I hit a wall with functional programming and decided to move back to world of
imperative codes.&lt;/p&gt;

&lt;h2 id=&#34;algorithms&#34;&gt;Algorithms&lt;/h2&gt;

&lt;p&gt;By the end of September I was writing Golang again with a second reading of The
Go Programming Language [DnK16] in unison with work on the very entertaining
&lt;a href=&#34;http://hackerrank.com/&#34;&gt;HackerRank.com&lt;/a&gt;. I would spend the next three months
doing algorithms problems on this site eventually making it to the 98th
percentile (of approx 600 000 coders). During this algorithms block I would read
the at times daunting Introduction to Algorithms [CLRS09]. I also made study of
The Algorithm Design Manual [SS12] and the online text
&lt;a href=&#34;http://opendatastructures.org/&#34;&gt;Open Data Structures&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;and-on-into-the-kernel&#34;&gt;And on into the Kernel&lt;/h2&gt;

&lt;p&gt;Mid January 2017 was linux.conf.au in Geelong. And, as was now customary,
attendance got me super psyched on Kernel development. On returning from the
conference I dropped work on algorithms and started Kernel programming. This
included re-reading Linux Device Drivers [CRK05] and making a (short lived)
attempt at writing a kernel from scratch.&lt;/p&gt;

&lt;p&gt;January though to mid March saw various Kernel development tasks. I mistakenly
did some what I later learned were very rude clean patches into the core
kernel. PowerPC got to feel my newbie wrath with some clean up patches and also
patches into the GNU Assembler for PPC assembly directives. Continued effort was
applied to the Eudyptula challenge also.&lt;/p&gt;

&lt;p&gt;At some stage I started to focus exclusively on the KS7010 Wi-Fi SDIO
driver. During this time I started to share what I had learned about Kernel
development with other upcoming newbies via the Kernel Newbies mailing
list. Somewhere here I got a tutorial presentation on Kernel hacking accepted
into Open Source Summit North America. It was these events and my continued work
on the Kernel that eventually lead me to the conclusion that my apprenticeship
was at an end. But like it says in Apprenticeship Patterns [HO10] in was not
until much later that I realized that these were the closing days.&lt;/p&gt;

&lt;p&gt;There were numerous other books I read during this time that didn&amp;rsquo;t get a
mention. Honourable mention goes to The Pragmatic Programmer [HnT99]. For a full
reading list see &lt;a href=&#34;http://tobin.cc/reading-list&#34;&gt;~/books&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I know spend my days hacking on the Kernel. If you got this far thank you for
your time. If this post is in anyway useful to you I am happy. May your days be
full of hard tractable problems.&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;bibliography&#34;&gt;Bibliography:&lt;/h4&gt;

&lt;p&gt;[ASS96] &lt;strong&gt;Structure and Interpretation of Computer Programs&lt;/strong&gt;
Harold Abelson, Gerald Jay Sussman, Julie Sussman&lt;/p&gt;

&lt;p&gt;[AT14] &lt;strong&gt;Modern Operating Systems&lt;/strong&gt;
Andrew S. Tanenbaum&lt;/p&gt;

&lt;p&gt;[BS15] &lt;strong&gt;Applied Cryptography&lt;/strong&gt;
Bruce Schneier&lt;/p&gt;

&lt;p&gt;[CLRS09] &lt;strong&gt;Introduction to Algorithms&lt;/strong&gt;
Thomas H. Cormen, Charles C. Leiserson, Ronald L. Rivest, Clifford Stein&lt;/p&gt;

&lt;p&gt;[CRK05] &lt;strong&gt;Linux Device Drivers 3rd Edition&lt;/strong&gt;
Jonathan Corbet, Alessandro Rubini, Greg Kroah-Hartman&lt;/p&gt;

&lt;p&gt;[DB09] &lt;strong&gt;Python Essential Reference&lt;/strong&gt;
David M. Beazley&lt;/p&gt;

&lt;p&gt;[DnK16] &lt;strong&gt;The Go Programming Language&lt;/strong&gt;
Alan A. A. Donovan, Brian W. Kernig&lt;/p&gt;

&lt;p&gt;[FnF96] &lt;strong&gt;The Little Schemer&lt;/strong&gt;
Daniel P. Friedman, Matthias Felleisen&lt;/p&gt;

&lt;p&gt;[HnT99] &lt;strong&gt;The Pragmatic Programmer&lt;/strong&gt;
Andrew Hunt, David Thomas&lt;/p&gt;

&lt;p&gt;[HO10] &lt;strong&gt;Apprenticeship Patterns&lt;/strong&gt; Guidance for the Aspiring Software Craftsman -
David H. Hoover and Adewale Oshineye&lt;/p&gt;

&lt;p&gt;[KD09] &lt;strong&gt;The Scheme Programming Language&lt;/strong&gt;
R. Kent Dybvig&lt;/p&gt;

&lt;p&gt;[Kn97v1] &lt;strong&gt;The Art of Computer Programming (volume 1)&lt;/strong&gt; Fundamental Algorithms -
Donald E. Knuth&lt;/p&gt;

&lt;p&gt;[Kn97v2] &lt;strong&gt;The Art of Computer Programming (volume 2)&lt;/strong&gt; Seminumerical Algorithms -
Donald E. Knuth&lt;/p&gt;

&lt;p&gt;[KnR12] &lt;strong&gt;The C Programming Language&lt;/strong&gt;
Brian W. Kernighan and Dennis M. Ritchie&lt;/p&gt;

&lt;p&gt;[KPS05] &lt;strong&gt;From Bash to Z Shell&lt;/strong&gt; Conquering the Command -
Oliver Kiddle, Jerry Peek, Peter Stephenson&lt;/p&gt;

&lt;p&gt;[LMC12] &lt;strong&gt;Version Control with Git&lt;/strong&gt;
Jon Loeliger, Matthew McCullough&lt;/p&gt;

&lt;p&gt;[MK10] &lt;strong&gt;The Linux Programming Interface&lt;/strong&gt;
Michael Kerrisk&lt;/p&gt;

&lt;p&gt;[MnS04] &lt;strong&gt;Beginning Linux Programming&lt;/strong&gt;
Neil Matthew, Richard Stones&lt;/p&gt;

&lt;p&gt;[RL10] &lt;strong&gt;Linux Kernel Development&lt;/strong&gt;
Robert Love&lt;/p&gt;

&lt;p&gt;[RM09] &lt;strong&gt;Clean Code&lt;/strong&gt;, A Handbook of Agile Software Craftsmanship -
Robert C. Martin&lt;/p&gt;

&lt;p&gt;[RnR03] &lt;strong&gt;UNIX Systems Programming&lt;/strong&gt;
Kay A. Robbins, Steven Robbins&lt;/p&gt;

&lt;p&gt;[RS11] &lt;strong&gt;Learning Perl&lt;/strong&gt;
Randal L. Schwartz, brian d foy, Tom Phoenix&lt;/p&gt;

&lt;p&gt;[RS12] &lt;strong&gt;Intermediate Perl&lt;/strong&gt;
Randal L. Schwartz, brian d foy, Tom Phoenix&lt;/p&gt;

&lt;p&gt;[RS13] &lt;strong&gt;Programming the World Wide&lt;/strong&gt;
Rebert W. Sebesta&lt;/p&gt;

&lt;p&gt;[SFR04] &lt;strong&gt;UNIX Network Programming&lt;/strong&gt;
W. Richard Stevens, Bill Fenner, Andrew M. Rudoff&lt;/p&gt;

&lt;p&gt;[SGS09] &lt;strong&gt;Real World Haskell&lt;/strong&gt;
Bryan O&amp;rsquo;Sullivan, John Goerzen and Don Stewart&lt;/p&gt;

&lt;p&gt;[SnR13] &lt;strong&gt;Advanced Programming in the UNIX Environment&lt;/strong&gt;
W. Richard Stevens, Stephen A. Rago&lt;/p&gt;

&lt;p&gt;[SS12] &lt;strong&gt;The Algorithm Design Manual&lt;/strong&gt;
Steven S Skiena&lt;/p&gt;

&lt;p&gt;[SV08] &lt;strong&gt;Essential Linux Device Drivers&lt;/strong&gt;
Sreekrishnan Venkateswaran&lt;/p&gt;

&lt;p&gt;[WH09] &lt;strong&gt;ARM Assembly Language&lt;/strong&gt;
William Hohl&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes Colorize Help</title>
      <link>/blog/k8s-color-help/</link>
      <pubDate>Tue, 29 Aug 2017 20:20:12 +1000</pubDate>
      
      <guid>/blog/k8s-color-help/</guid>
      <description>&lt;p&gt;Recently I started hacking on the Kubernetes (k8s) project. The code base is in Golang and is super
fun work on. Development is done via &lt;a href=&#34;https://github.com/kubernetes/&#34;&gt;GitHub&lt;/a&gt; and
&lt;a href=&#34;https://kubernetes.slack.com&#34;&gt;Slack&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Kubernetes is a complex project. It is not super big, in terms of line count, approximately 90 000
at the time of writing. The project is moving quite fast, I read today that they are merging about
30 pull requests a day. Development is divided among special interest groups (SIG). New developers
are directed towards SIG/CLI. As you might guess this group takes care of the command line interface
for Kubernetes. K8s clusters are administered via a command line tool called &lt;code&gt;kubectl&lt;/code&gt; (pronounced:
&amp;lsquo;kube-c-t-l&amp;rsquo; or &amp;lsquo;kube control&amp;rsquo;).&lt;/p&gt;

&lt;p&gt;Fast forward one month. I&amp;rsquo;ve been hacking away merrily now for a while on &lt;code&gt;kubectl&lt;/code&gt;. This has lead
me to some interesting open source libraries. The &lt;a href=&#34;https://github.com/spf13/cobra&#34;&gt;cobra&lt;/a&gt; library,
brought to you by the creators of &lt;a href=&#34;https://github.com/gohugoio/hugo&#34;&gt;Hugo&lt;/a&gt; (the static web site
generator that I am using to write this blog), is one of them.&lt;/p&gt;

&lt;p&gt;So, my issue, and the reason I am writing this post, was that I was struggling to decipher the
available options output by use of the &lt;code&gt;--help&lt;/code&gt; flag. Of course, first thing I did was throw a pull
request at Kubernetes with a proposed solution. Turns out there may be a more simple solution (remember 50%
of bug fixes introduce more bugs (Steve McConnel)). Introducing
&lt;a href=&#34;https://github.com/garabik/grc&#34;&gt;generic colorizer&lt;/a&gt;. This awesome tool written by Radovan Garabík
allows you to, as the name suggests, colorize anything.&lt;/p&gt;

&lt;p&gt;It is written in Python, you can get install instructions in the repository, or if you are running a
Debian based system just search the package manager for &lt;code&gt;grc&lt;/code&gt;. You will need a configuration file in
&lt;code&gt;~/.grc/grc.conf&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;While we are at it lets colorize &lt;code&gt;go test&lt;/code&gt; as well.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Go
\bgo.* test\b
conf.gotest

# Kubernetes
\bkubectl help\b
conf.kubectlhelp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Colorization is then achieved via regular expressions. You will need a configuration file for each
entry above. Here is &lt;code&gt;conf.kubectlhelp&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;regexp=  \#.*
colour=blue
-
regexp=--.+?(?==)
colour=yellow
-
regexp=^Other Commands
colour=red
-
regexp=^Usage:
color=cyan
-
regexp=^Examples:
color=cyan
-
regexp=^Options:
color=cyan
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and &lt;code&gt;conf.gotest&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;regexp==== RUN .*
colour=blue
-
regexp=--- PASS: .*
colour=green
-
regexp=^PASS$
colour=green
-
regexp=^(ok|\?) .*
colour=magenta
-
regexp=--- FAIL: .*
colour=red
-
regexp=[^\s]+\.go(:\d+)?
colour=cyan
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you like shell aliases you may like to define the following&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alias kch=&#39;/usr/bin/grc kubectl help&#39;
alias go=&#39;/usr/bin/grc go&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;voilà &lt;code&gt;kch&lt;/code&gt; now presents nice colorized output and you can easily discern the options for whichever
Kubernetes command you are investigating. Bonus points: &lt;code&gt;go test&lt;/code&gt; is colorized too.&lt;/p&gt;

&lt;p&gt;thanks&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Presentations</title>
      <link>/talks/</link>
      <pubDate>Wed, 02 Aug 2017 10:07:59 +1000</pubDate>
      
      <guid>/talks/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Talk: Intro to Kernel Hacking - finding things to work on&lt;/strong&gt;
(&lt;a href=&#34;http://tobin.cc/kernel-dev-finding-work.pdf&#34;&gt;slides&lt;/a&gt;)&lt;br /&gt;
22nd January 2018 - Linux.conf.au&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Tutorial: Hacking Device Drivers - How to get into kernel development&lt;/strong&gt; (&lt;a href=&#34;http://github.com/tcharding/kernel&#34;&gt;git repo&lt;/a&gt;)&lt;br /&gt;
14th September 2017 - Open Source Summit North America
(&lt;a href=&#34;http://tobin.cc/kernel-dev-tutorial.pdf&#34;&gt;slides&lt;/a&gt;)&lt;br /&gt;
23rd August 2017 - Central Coast Linux Users Group&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Talk: Getting Started With Linux Kernel Development&lt;/strong&gt;
(&lt;a href=&#34;http://tobin.cc/kernel-dev-intro.pdf&#34;&gt;slides&lt;/a&gt;)&lt;br /&gt;
2nd August 2017 - Central Coast Linux Users Group&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Talk: Unix, Linux and Cryptography going into the Future&lt;/strong&gt;&lt;br /&gt;
27th May 2015 - Australian Computer Society, Central Coast Chapter
(&lt;a href=&#34;https://www.acs.org.au/insightsandpublications/news-archive/2015/67141.html&#34;&gt;link&lt;/a&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Getting Started with Linux Kernel Development - Part 2: The Process.</title>
      <link>/blog/kernel-dev-2/</link>
      <pubDate>Thu, 20 Jul 2017 08:28:24 +1000</pubDate>
      
      <guid>/blog/kernel-dev-2/</guid>
      <description>

&lt;p&gt;Part 2 of this series outlines a method for starting to learn the
process of Linux kernel development. As stated in part 1, this is but
one method. The aim of this post is to illuminate a pathway starting
at the point when you have had your first patch merged into the
mainline. If you have not had your first patch merged you may like to
read &lt;a href=&#34;/blog/kernel-dev-1/&#34;&gt;part 1&lt;/a&gt; of this series.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Learning Linux kernel development consists of a number of conceptual
pieces. One way of discussing them is;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Understanding &lt;em&gt;how&lt;/em&gt; the kernel works.&lt;/li&gt;
&lt;li&gt;Understanding &lt;em&gt;what&lt;/em&gt; kernel code does.&lt;/li&gt;
&lt;li&gt;Understanding how to &lt;em&gt;change&lt;/em&gt; kernel code.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The first in this list takes years. The Linux kernel, like any operating
system, is a large complex software system. Understanding complex
systems takes time and effort.&lt;/p&gt;

&lt;p&gt;The second is more tangible, in order to be able to understand kernel
code you simply need experience reading and writing kernel
code. Circular argument I know, but let&amp;rsquo;s move onto number three of
our list for the moment and return to two shortly.&lt;/p&gt;

&lt;p&gt;In theory, one can get the kernel source code and hack away merrily in
the privacy of ones local machine. That kind of defeats the purpose
though. Open source is about collaboration, we want to learn how to
work on the kernel so we can contribute to, and collaborate with, the
kernel development community. If we want to be able to understand what
kernel code does we need to read [a lot of] code and write
code. And as we have established, if we are going to write kernel code
we want to be able to contribute the code back to the community. It is
therefore essential that we first become comfortable with the process of
changing the source and having our changes merged back into the
mainline.&lt;/p&gt;

&lt;p&gt;Fortunately, and in contrast to popular opinion, the Linux kernel is
extremely open and welcoming to new developers. There is a complete
system in place that provides new developers with a place to
learn the kernel development process. The aim of this blog post is to
shed some light on this system and outline &lt;em&gt;one&lt;/em&gt; method of using this
system to learn the Linux kernel development process.&lt;/p&gt;

&lt;h2 id=&#34;first-patch-series&#34;&gt;First Patch Series&lt;/h2&gt;

&lt;p&gt;At this stage, it is assumed you have a development environment set up
that is amenable to kernel development. You have read all the
documentation, within the kernel tree, in &lt;code&gt;Documentation/process/*&lt;/code&gt;.
You have subscribed to the
&lt;a href=&#34;https://lists.kernelnewbies.org/mailman/listinfo/kernelnewbies&#34;&gt;kernel newbies&lt;/a&gt;
mailing list and also the
&lt;a href=&#34;http://driverdev.linuxdriverproject.org/mailman/listinfo/driverdev-devel&#34;&gt;device driver&lt;/a&gt;
development mailing list. You are sorting your incoming email into
mailboxes so that mailing list mail can be viewed separately from
other mail. Finally, you have had a patch merged into Greg
Kroah-Hartman&amp;rsquo;s staging tree. More specifically, into the
staging-testing branch of that tree. If you are not at this stage you
may like to read &lt;a href=&#34;/blog/kernel-dev-1/&#34;&gt;part 1&lt;/a&gt; of
this series.&lt;/p&gt;

&lt;p&gt;Thus far, most of the information in this blog series is accessible
online without too much difficulty. Primarily on the
&lt;a href=&#34;https://kernelnewbies.org/&#34;&gt;kernel newbies&lt;/a&gt; web site. What follows
was, at the time of writing (or more accurately, six months
ago when I was at this stage) not easily garnered from the web.&lt;/p&gt;

&lt;p&gt;We will be working exclusively patching code within
&lt;code&gt;drivers/staging&lt;/code&gt;. While &lt;em&gt;trivial&lt;/em&gt; patches to the kernel proper can at
times get through the merge process it is, in my opinion,
disrespectful of the kernel maintainers time to attempt such
changes. Please learn from my mistakes. Pushing cleanup patches into
subsystems outside of &lt;code&gt;staging&lt;/code&gt; benefits the kernel very little. Doing
so trades your education for a non-trivial
amount of effort on the part of the maintainer. There is a system in
place for you to learn and that system is the &lt;code&gt;staging&lt;/code&gt; directory (and
the machinery in place around it).&lt;/p&gt;

&lt;h4 id=&#34;on-motivation&#34;&gt;On Motivation&lt;/h4&gt;

&lt;p&gt;Hackers tend to like working on &lt;em&gt;interesting&lt;/em&gt;
problems. It is of little use outlining a method for learning kernel
development if it is not interesting. Now arises then the question of
motivation. We must at this stage select some code to work on. Within
&lt;code&gt;drivers/staging&lt;/code&gt; there are a number of drivers. They are at various
stages of development. Some are on their way into the kernel, some may
be on their way out of the kernel and some may be stuck because of
some design issue i.e implementing an old API. Also the drivers may
vary in how complete or how functional they are.&lt;/p&gt;

&lt;p&gt;There are [at least] three things that may be considered in selecting a driver to
work on.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Does the driver present easily accessible code modifications.&lt;/li&gt;
&lt;li&gt;Does the driver belong to a subsystem of interest.&lt;/li&gt;
&lt;li&gt;Is hardware for the driver accessible.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These three questions are personal and you may or may not be able to
answer them. Also, there may be a trade off between them. You may like
to keep them in mind as you navigate your way around staging. You need
not confine yourself to a single driver, however, I found it more
engaging to do so.&lt;/p&gt;

&lt;h4 id=&#34;on-hardware&#34;&gt;On Hardware&lt;/h4&gt;

&lt;p&gt;It is not necessary in order to complete the steps in this blog post
to have access to real hardware. It is however necessary if you
intend to continue down the path of writing a functioning device
driver. Doing so is often stated as a stepping stone to kernel
development. A web search on the driver name will usually turn up some
information on the hardware that the driver is intended to run on. While
you may not like the idea of spending $200 on a piece of hardware that
you don&amp;rsquo;t need if you are going to spend 3 months writing a device
driver then the investment in your education is well worth it. You may
also like to consider the machine that the device requires, for
example if you intend working on a driver for an SDIO device you will
need a machine that has an SD card reader that supports the SDIO
protocol.&lt;/p&gt;

&lt;h4 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h4&gt;

&lt;p&gt;We will be using &lt;code&gt;checkpatch.pl&lt;/code&gt; to find some code to work on. If you
are still looking for a driver to work on you may like to run
checkpatch on the whole staging directory and pick a driver that
throws a lot of warnings.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scripts/checkpatch.pl -f --terse --strict drivers/staging/*/*.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may like to set up a shell alias for checkpatch&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alias checkpatch=&#39;/path/to/kernel/tree/scripts/checkpatch.pl -f&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You need the &lt;code&gt;-f&lt;/code&gt; option to have checkpatch work on source files, as
apposed to unified-diff formatted patches.&lt;/p&gt;

&lt;p&gt;At this stage we have a driver we are going to work on (henceforth
referred to as &lt;em&gt;your driver&lt;/em&gt;). We have the output from
checkpatch providing ideas for code to work on. Let us now start with
the actual steps intended for this blog post.&lt;/p&gt;

&lt;h3 id=&#34;1-pick-your-fixes&#34;&gt;1. Pick your Fixes&lt;/h3&gt;

&lt;p&gt;Using the above alias run checkpatch on the source (or header) files within your driver.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;checkpatch --strict --terse --show-types *.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Henceforth, for brevity, we will refer to all checkpatch outputs i.e ERROR, WARNING,
CHECK as &amp;lsquo;warnings&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;As you did when creating your first patch, have a look at the
different types of warnings (&lt;code&gt;--show-types&lt;/code&gt;). Read the code around the line in
question. At this stage there is little hope that you will understand
what the whole driver is doing. We are aiming, however, to fix
warnings for which we
do understand the surrounding code. At a minimum you should understand
what the surrounding block of code does.&lt;/p&gt;

&lt;p&gt;Pick three warning types that you feel you understand. For each
warning type fix &lt;em&gt;all&lt;/em&gt; instances of that warning type within the
driver, both header files and source files. Once you have fixed all
instances of a single warning type commit your changes. You read
&lt;a href=&#34;/blog/kernel-dev-1/&#34;&gt;part 1&lt;/a&gt; right? You read
&lt;code&gt;Documentation/process/submitting-patches.rst&lt;/code&gt; right? You read the
section &lt;code&gt;2) Describe your changes&lt;/code&gt; right? If you want to have any hope
of getting &lt;em&gt;real&lt;/em&gt; code changes into the kernel you need to be able to
describe your changes. The place to do this is the git log
message. The time to learn how to do this &lt;em&gt;well&lt;/em&gt; is now. Even though
your initial changes will be very simple you should describe them
fully and thoroughly as outline in the above mention kernel document,
specifically section 2.&lt;/p&gt;

&lt;p&gt;At the risk of repeating myself, no one &lt;em&gt;has&lt;/em&gt; to respond to your
email/patches when doing kernel development. If you want your patches
to be taken seriously you &lt;em&gt;must&lt;/em&gt; present them in the correct
manner. The more you display that you understand the process and
correctly adhere to it the better your chances of success in kernel
development.&lt;/p&gt;

&lt;p&gt;Please use correct, both grammatically and technically, descriptions
of your code changes. Use the correct format for the git log message
and for the summary phrase. The summary phrase will be used in the
subject line when your patch is in email form. This information is
contained in section &lt;code&gt;14) The canonical patch format&lt;/code&gt; of
&lt;code&gt;submitting-patches.rst&lt;/code&gt;. Also, every other patch on the device
drivers mailing list &lt;em&gt;should&lt;/em&gt; have the same form. Newbie mistakes
not-withstanding. There is a strict form for a reason, you will have
better success if you follow it.&lt;/p&gt;

&lt;h3 id=&#34;2-check-your-fixes&#34;&gt;2. Check your Fixes&lt;/h3&gt;

&lt;p&gt;At this stage you have three commits in your git history and you have
been working on a branch created off of staging-next. Now we are going
to try to eliminate mistakes.&lt;/p&gt;

&lt;h4 id=&#34;on-making-mistakes-in-public&#34;&gt;On Making Mistakes in Public&lt;/h4&gt;

&lt;p&gt;Kernel development is done in the open. I believe that one of the
reasons people are so intimidated by LKML and kernel development in
general is that making mistakes in public hurts. It hurts
bad. There is nothing you can read that is going to make it hurt less
when (and you will) you write some brain dead comment in an email on a
kernel mailing list. Or when you breach some &lt;em&gt;simple&lt;/em&gt; protocol that
you well know, making you look like a complete goose. Mistakes happen,
mistakes are tolerated. Repeated mistakes, especially after being
corrected, are not so well tolerated. And I personally do not see why
they should be. We are striving for excellence, mediocrity has no
place here. Continually striving for excellence is one of the reasons
open source software is such a beautiful pursuit.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. Read the diff for each commit&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Patches submitted to kernel mailing lists are typically reviewed
by reading the diff. At first this may seem difficult since there are
some peculiarities to the diff format but if you check each of your
patches first by reading the diff you will get good at catching
mistakes. Here is a shell function that you may find useful&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    git-log-patch() {
        local commit

        if (( $# &amp;lt; 1 )); then
            commit=&amp;quot;HEAD~&amp;quot;          # default to last commit
        else
            commit=&amp;quot;$1&amp;quot;
        fi

        git log --color=always --patch --reverse &amp;quot;${commit}&amp;quot;.. | less 
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git-log-patch&lt;/code&gt; accepts as argument the commit prior to that which you wish to
view, as usual this can be a hash or &lt;code&gt;HEAD~&lt;/code&gt;. It then displays each
commit in succession in patch format.  You may also find this shell
function useful when viewing your git index&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git-log-abbrev () {
    # number of commits from index to view, default 1
    local COMMITS=${1:-20} 

    git log -$COMMITS --pretty=oneline --abbrev-commit --reverse
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you find mistakes in one of the commits then you may like to
rebase in order to fix.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    git rebase -i HEAD~~~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rebasing takes practice, that is one reason why we are doing a
three patch series. Rebasing a 20 patch series is more prone to
error. You will need to rebase to edit the commit log as well as to
make code changes. It is &lt;em&gt;very&lt;/em&gt; easy to mix up your commits, changes
from one commit find their way into the next commit if you do not use
the correct git commands when adding files and continuing the rebase.
Any time you rebase I &lt;em&gt;strongly&lt;/em&gt; suggest re-reading the whole
series. Catching your mistakes yourself is much easier on the ego than
submitting patches with blatant errors. See &amp;lsquo;On Making Mistakes in
Public&amp;rsquo; above.&lt;/p&gt;

&lt;h3 id=&#34;3-create-the-patch-set&#34;&gt;3. Create the Patch Set&lt;/h3&gt;

&lt;p&gt;At this stage you have three commits in your git index. Each commit
does one thing and one thing only, in this case each commit fixes one
checkpatch warning type. Your git log clearly states the reason for
this patch (checkpatch emits warning XYZ) and clearly states how the
patch goes about fixing the issue. Now we can create the patch series
(or patch set).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git format-patch -3 -o tmp/path/to/patches --cover-letter
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will output 4 files to the specified path. You can check each
file at this stage for correctness also. We can now turn our attention
to the cover letter. A cover letter is not required but it is not hard
to create and makes the patch set a little more tidy. The content of
the cover letter can range from describing and justifying every patch
to briefly outlining the whole series. For a checkpatch series like
this a quick line or two saying what the series does is
sufficient. The cover letter is also where you may like to indicate
the level of testing carried out. Let&amp;rsquo;s go right ahead and assume you
have not tested your changes. This leads on to the next step in
catching mistakes&lt;/p&gt;

&lt;h4 id=&#34;verify-your-patches-build&#34;&gt;Verify your Patches Build&lt;/h4&gt;

&lt;p&gt;Each and every patch that is applied to the Linux kernel must leave
the kernel in a sane state. This means that each of your patches must
&lt;strong&gt;apply and build&lt;/strong&gt;. There are a few reasons for this. It aids
bisecting and bug hunting. Not necessarily every patch in a series
will be applied, a maintainer may pick out a subset of the patches to
apply. And finally down stream [distribution] developers may cherry
pick patches to apply to their kernels.&lt;/p&gt;

&lt;p&gt;Patches to staging that do not apply are caught by Greg&amp;rsquo;s robots. You
get an email saying so, no hard feelings. Patches that do not build
however are viewed much more dimly. Again, please learn from my
mistakes. Apply each patch individually and build the kernel for each
patch before submitting a patch series. Here is a link to a
&lt;a href=&#34;https://github.com/tcharding/kernel/blob/master/apply-and-build.sh&#34;&gt;script&lt;/a&gt;
I wrote to carry out this task.&lt;/p&gt;

&lt;p&gt;If you have access to other machines then it is a
nice idea to apply and build your patch set on different
architectures. Particularly Power PC so I read somewhere in the kernel
docs.&lt;/p&gt;

&lt;p&gt;Back to the cover letter, you may like to add a line at the end
stating&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Code is untested. Builds on x86_64 and PowerPC.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-submit-the-patch-set&#34;&gt;3. Submit the Patch Set&lt;/h3&gt;

&lt;p&gt;As for your single patch previously the patch recipients can be
garnered from the TODO file within the driver or by running the
&lt;code&gt;get_maintainer.pl&lt;/code&gt; script on a patch or file. If you manually fill the
&lt;code&gt;To:&lt;/code&gt; and &lt;code&gt;Cc:&lt;/code&gt; header fields within the cover letter then you can use
the following git command to send the patch set.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git send-email --to-cover --cc-cover path/to/dir/*.patch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once again, you may like to send the series to yourself first to check
it for mistakes.&lt;/p&gt;

&lt;p&gt;Now wait. You will get a response from either a reviewer, Greg&amp;rsquo;s
robots, the kbuild test robot, or from Greg himself. If anyone makes
suggestions, thank them for their input and follow their
suggestions. Do not submit a second version (see below) without seeing
to each and every suggestion made by a reviewer.&lt;/p&gt;

&lt;h3 id=&#34;4-submitting-patch-set-version-2&#34;&gt;4. Submitting Patch Set Version 2&lt;/h3&gt;

&lt;p&gt;If changes to your patch set are necessary you will need to submit a
second (and third &amp;hellip;) version. You need to deal with all comments to
your patch on the mailing list. Greg receives &lt;em&gt;a lot&lt;/em&gt; of patches each
day, and response or contention typically pushes a patch to the bottom
of the list of patches he manages, to get back to the top of the list
(and be merged) you need to incorporate any reviewer suggestions into
a new version. At this early stage you are most likely going to
need to incorporate the suggestion as apposed to arguing your point.&lt;/p&gt;

&lt;p&gt;If you get more than one suggestion you can implement all the changes
at once. You do so by rebasing your patch set so as to finish up, as before,
with just three patches. Once you are happy with the new series you must
re-submit it. There are two things to note when doing so. The new
subject for the patch set will be the same as the old except it will
include &lt;code&gt;[PATCH v2]&lt;/code&gt; in the subject. You can generate this using&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git format-patch -3 --subject-prefix=&#39;PATCH v2&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Your cover letter will be the same as for the previous version except
you need to add a section at the bottom that outlines the change
history. Let&amp;rsquo;s assume you are up to version 3, your cover letter may
include something like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;v2 -&amp;gt; v3
- Fix whitespace issue as suggested by review. 

v1 -&amp;gt; v2
- Use u8 instead of uint8.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you are working on a single patch instead of a series, this change
history is still required. The place to put it is below the &lt;code&gt;----&lt;/code&gt;
within the patch. Things below the dashed line are not included in the
git index when the patch is applied.&lt;/p&gt;

&lt;h4 id=&#34;on-arguing-with-reviewers&#34;&gt;On Arguing with Reviewers&lt;/h4&gt;

&lt;p&gt;TL;DR; Don&amp;rsquo;t argue with reviewers.&lt;/p&gt;

&lt;p&gt;Linux kernel maintainers and patch reviewers are in short supply, do
not waste there valuable time arguing with them. At this early stage
it is highly unlikely that you know more about kernel development than
the developer reviewing your patch. Sure, reviewers make mistakes,
sometimes email is misinterpreted. In this case by all means re-state
your position in a different, more thoroughly articulated, manner. If
the reviewer repeats the original sentiment then please accept that
you are probably wrong. There may be something that you have not yet
learned that justifies the reviewers position. A reviewer is not
required to spell out &lt;em&gt;exactly&lt;/em&gt; why something is wrong, they are
reviewers not tutors. If you ask for pointers as to where you can
learn more about why you are wrong you will do much better than
attempting to prove you are correct. And if finally you still do not
agree with the reviewers position just drop the patch and move onto
something else, you are fixing staging bugs here not re-writing the
scheduler. You are supposed to be learning, forge another patch set on
something different and come back to the contentious issue when you
have learned some more.&lt;/p&gt;

&lt;p&gt;The more respectful of other developers time and efforts you are the
more help you will receive. It is not magic, just simple human
interactions.&lt;/p&gt;

&lt;h3 id=&#34;lather-rinse-repeat&#34;&gt;Lather, Rinse, Repeat&lt;/h3&gt;

&lt;p&gt;Above I have attempted to outline a method for learning the Linux
kernel development process while controlling some of the complexity
that is inherent in learning a new complex software system. The issues
touched on are issues I came up against while learning. You may well come
up against different issues, each of us is different with different
skill sets and personalities. One thing is for sure, you will not
learn the process without repeating it many times. So go ahead, enjoy
yourself, fix all the checkpatch warnings in that driver. If there are
not enough there, pick another driver and learn it also. Once you are
comfortable with the process and getting more comfortable with kernel
code you may like to try fixing &lt;code&gt;Sparse&lt;/code&gt; warnings. Pass the &lt;code&gt;C=2&lt;/code&gt;
option to your build command to run Sparse.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make -j9 C=2 M=drivers/staging/FOO
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;final-tips&#34;&gt;Final Tips&lt;/h3&gt;

&lt;p&gt;Here are a couple of final tips you may find useful&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If you finish a patch series late at night or when tired wait until
the next day before sending it. You may realize you have made a
mistake once you are better rested.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Wait at least 24 hours before submitting a new version. This gives
reviewers more time and allows you to include more changes in each
version i.e less churn and less demand on maintainers/reviewers.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Good luck&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Getting Started with Linux Kernel Development - Part 1: First Patch.</title>
      <link>/blog/kernel-dev-1/</link>
      <pubDate>Wed, 19 Jul 2017 10:28:42 +1000</pubDate>
      
      <guid>/blog/kernel-dev-1/</guid>
      <description>&lt;p&gt;This is the first in a series of posts about getting started in Linux
kernel development. Most of what is written in this post is already
available on the web. It is provided here for completeness and as a pre-amble to the next post in the series.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;The aim of this series is to outline &lt;em&gt;one&lt;/em&gt; way of getting started with
Linux kernel development. It is by no means the only way and it is
quite possibly not even the &lt;em&gt;best&lt;/em&gt; way.&lt;/p&gt;

&lt;h4 id=&#34;assumptions&#34;&gt;Assumptions&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;You are inherently interested in how the Linux kernel works.&lt;/li&gt;
&lt;li&gt;You know the C programming language &lt;em&gt;well&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;You know how to use git.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Good luck.&lt;/p&gt;

&lt;h2 id=&#34;first-patch&#34;&gt;First Patch&lt;/h2&gt;

&lt;p&gt;This post will describe steps you may take in order to get your first
patch merged into the mainline kernel.&lt;/p&gt;

&lt;p&gt;Do not submit patches to any part of the kernel outside of
drivers/staging whilst getting started with kernel development.&lt;/p&gt;

&lt;h3 id=&#34;1-set-up-your-tools&#34;&gt;1. Set up your tools&lt;/h3&gt;

&lt;h4 id=&#34;editor&#34;&gt;Editor&lt;/h4&gt;

&lt;p&gt;The kernel uses a specific coding style, you may like to configure
your editor to support this.&lt;/p&gt;

&lt;h4 id=&#34;email&#34;&gt;Email&lt;/h4&gt;

&lt;p&gt;All kernel development is done in the open, this means via mailing
lists. Get comfortable with your email client. Do not use HTML when
sending email to kernel mailing lists.&lt;/p&gt;

&lt;h4 id=&#34;git&#34;&gt;Git&lt;/h4&gt;

&lt;p&gt;Configure git with your email address and name.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[user]
    email = joe@email.com
    name = Joe Developer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All kernel patches must contain a tag &lt;code&gt;Signed-off-by: Joe Developer &amp;lt;joe@email.com&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;You may wish to add to your git config&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[format]
    signOff = true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Pro Tip:&lt;/strong&gt; If you already have git configured with your GitHub username
then add the real name configuration lines to the git config file
within your kernel development tree (see task 3 below).&lt;/p&gt;

&lt;h3 id=&#34;2-subscribe-to-mailing-lists&#34;&gt;2. Subscribe to mailing lists&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://lists.kernelnewbies.org/mailman/listinfo/kernelnewbies&#34;&gt;Kernel newbies&lt;/a&gt; mailing list.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://driverdev.linuxdriverproject.org/mailman/listinfo/driverdev-devel&#34;&gt;Device driver&lt;/a&gt;
mailing list.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Pro Tip:&lt;/strong&gt; Do not bother subscribing to LKML at this stage.&lt;/p&gt;

&lt;p&gt;You may like to sort emails from mailing lists into
separate mail boxes. Example regex for sorting;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;^List-ID:.*&amp;lt;driverdev-devel.linuxdriverproject.org&amp;gt;$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Pro Tip:&lt;/strong&gt; Always maintain the complete CC list when responding to email
on a kernel mailing list.&lt;/p&gt;

&lt;h3 id=&#34;3-set-up-development-tree&#34;&gt;3. Set up development tree&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Clone Greg Kroah-Hartman&amp;rsquo;s tree&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging.git/&#34;&gt;https://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging.git/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Set up tracking branch on staging-next (or staging-testing)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;At this stage you may like to limit your scope within the kernel tree to the following;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Documentation/process/*  
drivers/staging/*  
include/linux/*  
include/uapi/*  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reasoning is that it is very easy to get overwhelmed while
learning a new system as large as the Linux kernel. Limiting scope is
one tool useful in controlling the complexity of the task.&lt;/p&gt;

&lt;h3 id=&#34;4-fix-something&#34;&gt;4. Fix something&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Run checkpatch against drivers in staging until you find a warning
that you feel you can fix.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ scripts/checkpatch.pl -f --terse --strict --show-types drivers/staging/FOO/*.c&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pro Tip:&lt;/strong&gt; Do not fix line over 80 warnings.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Fix &lt;em&gt;all&lt;/em&gt; instances of the warning type within the driver you have
chosen. If a job is worth doing it is worth doing properly.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Commit your changes as a single commit, write a &lt;em&gt;correct&lt;/em&gt; git log
for the commit. Read &lt;code&gt;Documentation/process/submitting-patches.rst&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Git log messages must be of a specific format and content. At
first they are difficult and time consuming to write. You may even
find you spend more time writing git logs at first than code. Keep
at it, you will learn a lot from doing it thoroughly.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;5-create-a-patch&#34;&gt;5. Create a patch&lt;/h3&gt;

&lt;p&gt;At this stage you have created a branch off of staging-next, edited
the source and have a single commit containing the changes. The next
step is to attempt to eliminate mistakes and then create the patch.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Check the commit is correct&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ git log --color=always --patch --reverse &amp;quot;HEAD~&amp;quot;.. | less&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Read through the diff, this is what reviewers will see. Make sure the
changes are correct and nothing spurious has snuck into your patch.&lt;/p&gt;

&lt;p&gt;Your commit should build without warnings. During development you may
like to build the driver (without linking it) using&lt;/p&gt;

&lt;p&gt;&lt;code&gt;make M=drivers/staging/FOO&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;You may also like to build and link the kernel with extra warnings enabled.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;make -j9 EXTRA-CFLAGS=-W&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Output the patch&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ git format-patch HEAD~ -o path/to/put/patch&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Check you patch applies&lt;/p&gt;

&lt;p&gt;Kernel development moves fast, another patch may have been merged that
touches the same lines of code. Apply and build your patch on the
staging-testing branch of Greg Kroah-Hartman&amp;rsquo;s staging tree.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pro Tip:&lt;/strong&gt; Work off of staging-next but make sure your patches apply
to staging-testing before you submit them to the driver dev mailing list.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;5-submit-the-patch&#34;&gt;5. Submit the patch&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Check the TODO file for whom to send the patch to, or use&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ scripts/get_maintainer.pl XYZ.patch&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Submit the patch. You may like to use git&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git send-email
    --to=&#39;Greg Kroah-Hartman &amp;lt;gregkh@*****.org&amp;gt;&#39;
    --cc=&#39;Joe Maintainer &amp;lt;bar@baz.com&amp;gt;, driverdev-devel@*****.org&#39;
    XYZ.patch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is a good idea to first send the patch to yourself to check you
have everything correct.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Respond to feedback. If asked to do so, fix your patch and
re-submit.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pro Tip:&lt;/strong&gt; Wait at least two weeks before following up on any email
sent to a kernel mailing list.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;At this stage, if all went successfully, you should get an email from
Greg Kroah-Hartman saying that your patch was merged into
staging-testing. From here your patch will automatically transition to
staging-next then, when the next merge window opens, will by merged into
Linus&amp;rsquo; mainline.&lt;/p&gt;

&lt;h2 id=&#34;final-note&#34;&gt;Final Note&lt;/h2&gt;

&lt;p&gt;You should now have a development environment set up suitable for
Linux kernel development. There will of course be further tweaking to
be done, especially in regards to your email setup. You have now seen some the
custom tools used in kernel development, the &lt;code&gt;scripts&lt;/code&gt; directory
contains many more. You should have learned a thing or two from reading the docs in
&lt;code&gt;Documentation/process&lt;/code&gt;. Now is probably a good time to read
everything in that directory. Don&amp;rsquo;t worry if it does not all sink in,
you will need to read, and re-read, the docs many times yet.&lt;/p&gt;

&lt;p&gt;Getting your first patch merged into the Linux kernel is an exciting
event. Well done if you have got this far, your journey has but
started.&lt;/p&gt;

&lt;p&gt;Welcome to the Linux kernel and good luck.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Resume of Tobin Harding: Linux Programmer</title>
      <link>/resume/</link>
      <pubDate>Mon, 17 Apr 2017 21:00:43 +1100</pubDate>
      
      <guid>/resume/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Undergraduate&lt;/strong&gt; and &lt;strong&gt;postgraduate&lt;/strong&gt; degrees in computer science.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;24 month&lt;/strong&gt; software apprenticeship.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;8 months&lt;/strong&gt; full time &lt;strong&gt;Linux kernel&lt;/strong&gt; development experience.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Linux kernel maintainer&lt;/strong&gt;, 100+ patches merged into the mainline.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kubernetes&lt;/strong&gt; contributor.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;98th percentile&lt;/strong&gt; in algorithms on &lt;a href=&#34;https://www.hackerrank.com/tcharding&#34;&gt;HackerRank&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;12 years&lt;/strong&gt; experience using &lt;strong&gt;Linux&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Founder&lt;/strong&gt; of Central Coast Linux Users Group&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;open-source-experience&#34;&gt;Open Source Experience&lt;/h2&gt;

&lt;p&gt;Open source contributions made to the following projects, among others:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/log/?qt=grep&amp;amp;q=me%40tobin.cc&#34;&gt;Linux Kernel&lt;/a&gt;
(C ).&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/pulls?utf8=%E2%9C%93&amp;amp;q=is%3Apr+author%3Atcharding+zfs+&#34;&gt;ZFS&lt;/a&gt; (C ).&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/pulls?utf8=%E2%9C%93&amp;amp;q=is%3Apr+author%3Atcharding+kubernetes+&#34;&gt;Kubernetes&lt;/a&gt; (Go)&lt;/li&gt;
&lt;li&gt;Gonum graph library (Go).&lt;/li&gt;
&lt;li&gt;OpenBazaar-Server (Python).&lt;/li&gt;
&lt;li&gt;Guile Scheme (Scheme, C).&lt;/li&gt;
&lt;li&gt;Binutils, GNU Assembler (Documentation).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Currently working on the Linux kernel, primarily the Kernel Self Protection
Project. Also interested in filesystems, networking, device drivers and
security. Current Linux kernel maintainer of the leaking_addresses.pl
script. 100+ patches merged into the mainline.&lt;/p&gt;

&lt;p&gt;Previously worked on layer 2 networking code within the Linux kernel. Focus on
the KS7010 Wi-Fi driver (drivers/staging/ks7010).  Also some Power PC work.
While resolving Power PC kernel issues contributed documentation patches to the
GNU Assembler, as well as an assembly code patch series within the kernel
PowerPC code.  Minor bug fixes and clean up patches to the Power PC tree as well
as trivial cleanup patches into the kernel core (net, purgatory, mm).&lt;/p&gt;

&lt;p&gt;While studying data structures and algorithms contributed code, and design test
implementation, to the Gonum graph library written in Golang.  Utilized graph
library as reference while implementing solutions to graph problems on
HackerRank.&lt;/p&gt;

&lt;p&gt;Contributed to the Free Software Foundation Guile project.  Interacted with
Guile community via public mailing list.  Iterated multiple revisions in order
to assimilate a personal fix into a patch that was acceptable by the community.
Produced a solution to a known outstanding issue requiring a multi-language
patch set in C and Scheme.&lt;/p&gt;

&lt;p&gt;Two months focused work on OpenBazaar Server code in Python.  First non-company
contributor to the project.  Most patches were unit testing and code
refactoring.  Some work on the command line interface and interoperability
between operating systems.&lt;/p&gt;

&lt;h2 id=&#34;education&#34;&gt;Education&lt;/h2&gt;

&lt;h3 id=&#34;apprenticeship&#34;&gt;Apprenticeship&lt;/h3&gt;

&lt;p&gt;24 month software development apprenticeship.  Worked assiduously on becoming a
competent, professional programmer.  Maintained a minimum 40 hour working week
(typically 50+).
 &lt;a href=&#34;https://github.com/tcharding/work-logs&#34;&gt;Logged&lt;/a&gt; hours and topics
worked.  Topics include; computer architecture,
programming languages and theory, operating systems, data structures
and algorithms, professional software development methodology and practices.  See
below ‘code written in last 12 months’ and
&lt;a href=&#34;http://tobin.cc/reading-list&#34;&gt;~/books&lt;/a&gt;.  Text highlights include;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;The Art of Computer Programming&lt;/strong&gt; (volumes 1 and 2) Donald E. Knuth&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Advanced Programming in the UNIX Environment&lt;/strong&gt; W. Richard Stevens, Stephen A. Rag&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Structure and Interpretation of Computer Programs&lt;/strong&gt; Harold Abelson, Gerald
Jay Sussman with Julie Sussman&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Applied Cryptography&lt;/strong&gt; Bruce Schneier&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Clean Code, A Handbook of Agile Software Craftsmanship&lt;/strong&gt; Robert C. Martin&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;See &lt;a href=&#34;https://github.com/tcharding/self_learning&#34;&gt;Github&lt;/a&gt; repository for code
written during apprenticeship.  All code worked on is open source unless
explicitly requested otherwise (i.e Project Euler, Eudyptula Challenge).&lt;/p&gt;

&lt;h3 id=&#34;graduate-diploma-in-computer-science-pass-with-high-distinction&#34;&gt;Graduate Diploma in Computer Science [Pass with High Distinction]&lt;/h3&gt;

&lt;p&gt;University of New England, Australia (completed 2014).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Parallel and Distributed Computing.&lt;/li&gt;
&lt;li&gt;Computer Architecture and Assembler.&lt;/li&gt;
&lt;li&gt;C++ Programming.&lt;/li&gt;
&lt;li&gt;Programming Languages for Artificial Intelligence.&lt;/li&gt;
&lt;li&gt;Web and Internet Programming.&lt;/li&gt;
&lt;li&gt;Information Technology Project (dentist patient management application in Objective C).&lt;/li&gt;
&lt;li&gt;Graduate Diploma in Computer Science Project (UNIX shell written in C).&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;bachelor-of-science&#34;&gt;Bachelor of Science&lt;/h3&gt;

&lt;p&gt;University of Sydney, Australia (completed 2008).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Awarded Bachelor of Science majoring in computer science.&lt;/li&gt;
&lt;li&gt;Completed double major, software development and computer networking.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;outside-experience&#34;&gt;Outside Experience&lt;/h2&gt;

&lt;p&gt;Founded the Central Coast Linux Users Group of New South Wales in
February 2014.  Announced the intent prior, at Linux open source
conference, Linux.conf.au.  Lead role in organizing and administering
the group.  Set up a unincorporated association for
governance.  Acquired sponsorship of venue to hold monthly
meetings.  Financially supported the group for the first three years.&lt;/p&gt;

&lt;p&gt;Given presentations on software related topics at the Open Source Summit North
America 2017, Central Coast Linux Users Group (multiple) and the Australian
Computer Society (2015).&lt;/p&gt;

&lt;h2 id=&#34;motivation-for-writing-code&#34;&gt;Motivation for Writing Code&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;The social interaction of programming on a project together with others.&lt;/li&gt;
&lt;li&gt;Continually learning and refining skills and technique.&lt;/li&gt;
&lt;li&gt;How good ‘clean code’ looks on the screen.&lt;/li&gt;
&lt;li&gt;The feeling when an insurmountable problem dissolves.&lt;/li&gt;
&lt;li&gt;Constantly chasing perfection, efficiency of space and time, beauty of code.&lt;/li&gt;
&lt;li&gt;Programming craftsmanship.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;buzz-words&#34;&gt;Buzz Words&lt;/h2&gt;

&lt;p&gt;ARM, x86_64, MIPS, PowerPC,&lt;br /&gt;
Linux, Ubuntu, Emacs, Zsh, Mutt, Git,&lt;br /&gt;
Haskell, Scheme Lisp, Assembler, C, Go, Python, Perl, Java, C++, Objective-C, Prolog, Bash&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux Kernel Selftest Framework</title>
      <link>/blog/kselftests/</link>
      <pubDate>Thu, 02 Feb 2017 11:38:39 +1100</pubDate>
      
      <guid>/blog/kselftests/</guid>
      <description>&lt;p&gt;&lt;em&gt;Kselftest is an effort to enable a developer-focused unit test
framework in the kernel to ensure the quality of new kernel
releases.&lt;/em&gt;&lt;br /&gt;
    - Shua Khan&lt;/p&gt;

&lt;p&gt;Install and run Linux kernel selftests on Ubuntu 16.04&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Presentation &lt;a href=&#34;reference:
http://www.elinux.org/images/6/61/Linux_Kernel_Selftest_Framework_-_Quality_Control_for_New_Releases.pdf&#34;&gt;slides&lt;/a&gt;
by Shua Khan on self test framework.&lt;br /&gt;
Git &lt;a href=&#34;git: https://git.kernel.org/cgit/linux/kernel/git/shuah/linux-kselftest.git&#34;&gt;repository&lt;/a&gt; for the project.&lt;/p&gt;

&lt;h2 id=&#34;test-machine&#34;&gt;Test machine&lt;/h2&gt;

&lt;p&gt;Product: Intel&amp;reg; Core&amp;trade; i5-4590 CPU @ 3.30GHz&lt;br /&gt;
Description:    Ubuntu 16.04.1 LTS&lt;br /&gt;
Kernel: Linux 4.10.0-rc6+ x86_64 GNU/Linux&lt;/p&gt;

&lt;h2 id=&#34;build-on-ubuntu&#34;&gt;Build on Ubuntu&lt;/h2&gt;

&lt;p&gt;The following packages are required&lt;/p&gt;

&lt;p&gt;libcap-ng-dev&lt;br /&gt;
libnuma-dev&lt;br /&gt;
libcap-dev&lt;br /&gt;
libpopt-dev&lt;br /&gt;
libmount-dev&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ KTREE = /path/to/kernel/tree  
$ cd $KTREE/tools/testing/selftests  
$ make  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;run&#34;&gt;Run&lt;/h2&gt;

&lt;p&gt;Some tests require root privileges to run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo make run_tests
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Your machine may appear to die as the tests start.
Tests run in approx 10 minutes on this machine, your results may vary.&lt;/p&gt;

&lt;p&gt;Test targets may be specified using&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo make TARGETS=&#39;size&#39; run_tests
$ sudo make TARGETS=&#39;net networking&#39; run_tests
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Single or multiple targets are accepted. Target names come from
directory names under tools/testing/selftests.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fenwick Trees in Golang</title>
      <link>/blog/fenwick/</link>
      <pubDate>Sat, 07 Jan 2017 11:21:35 +1100</pubDate>
      
      <guid>/blog/fenwick/</guid>
      <description>&lt;p&gt;A Fenwick tree is a data structure that holds an ordered collection and supports
the operations &lt;code&gt;sum&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt;, both in &lt;em&gt;O(log n)&lt;/em&gt; time.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;In its most basic form the tree stores an array of integers. &lt;code&gt;Sum&lt;/code&gt; calculates
the cumulative total of the first &lt;em&gt;n&lt;/em&gt; integers and &lt;code&gt;update&lt;/code&gt; modifies an element. Theoretically one is not limited to addition of integers when using
Fenwick trees. We can however limit the discussion of Fenwick trees, without
loss of generality, to trees involving integers and summing/updating using
addition&lt;em&gt;[1]&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;See this Github
&lt;a href=&#34;https://github.com/tcharding/types/tree/master/trees/fenwick/fenwick-mul&#34;&gt;repository&lt;/a&gt;
for an implementation using multiplication.&lt;/p&gt;

&lt;h2 id=&#34;problem-statement&#34;&gt;Problem Statement&lt;/h2&gt;

&lt;p&gt;Design a data structure that supports cumulative accumulation of values and also supports
modification of the values.&lt;/p&gt;

&lt;h2 id=&#34;naive-solution&#34;&gt;Naive Solution&lt;/h2&gt;

&lt;p&gt;A naive approach to designing such a data structure may choose to store the values in an array
&lt;code&gt;[1, 2, 3, 4, 5]&lt;/code&gt;. Summation is then achieved by iterating the array and runs in
&lt;em&gt;O(n)&lt;/em&gt;. Updating a value in the array is done via indexing and quite clearly
runs in &lt;em&gt;O(1)&lt;/em&gt; or &lt;em&gt;constant&lt;/em&gt; time.&lt;/p&gt;

&lt;p&gt;Perhaps we may choose to optimize for cumulative summation. This may be done by instead of
storing the values, storing the cumulative totals &lt;code&gt;[1, 3, 6, 10, 15]&lt;/code&gt;.
Summation is now a matter of indexing and runs in &lt;em&gt;0(1)&lt;/em&gt; time. However in order to update a value we must
traverse the array from the updated value to the end of the array updating each
value as we go. This is, once again &lt;em&gt;0(n)&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;fenwick-tree-solution&#34;&gt;Fenwick Tree Solution&lt;/h2&gt;

&lt;p&gt;The problem that a Fenwick tree solves is the ability to both sum a series and modify
it in less that &lt;em&gt;O(n)&lt;/em&gt; running time.&lt;/p&gt;

&lt;p&gt;According to &lt;a href=&#34;https://en.wikipedia.org/wiki/Fenwick_tree&#34;&gt;Wikipedia&lt;/a&gt; Paul
Fenwick proposed the data structure in 1994. How Mr Fenwick came up with this
structure I have no idea but in order to do so he made some very interesting
observations. Let us start with a binary search tree with the nodes
positioned in such a way that an &lt;em&gt;inorder&lt;/em&gt; tree traversal would give the same
order as the collection we wish to store. Each node has an associated &lt;code&gt;value&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The first observation is that we can update a node by setting the nodes &lt;code&gt;value&lt;/code&gt;
and then &lt;em&gt;bubble&lt;/em&gt; the new value up the tree updating each internal node&amp;rsquo;s &lt;code&gt;value&lt;/code&gt;
&lt;em&gt;iff&lt;/em&gt; that node was reached via it&amp;rsquo;s &lt;em&gt;right&lt;/em&gt; child.&lt;/p&gt;

&lt;p&gt;Doing so maintains a tree that supports the calculation of
cumulative total by using a similar technique, namely; when finding the sum for a
node we start with the nodes &lt;code&gt;value&lt;/code&gt; then traverse up the tree, adding the internal nodes &lt;code&gt;value&lt;/code&gt;
as we pass if the node was reached by its &lt;em&gt;left&lt;/em&gt; child.&lt;/p&gt;

&lt;p&gt;Further explanation can be found in this very nice
&lt;a href=&#34;http://cs.stackexchange.com/questions/10538/bit-what-is-the-intuition-behind-a-binary-indexed-tree-and-how-was-it-thought-a&#34;&gt;StackExchange&lt;/a&gt;
post.&lt;/p&gt;

&lt;p&gt;The second observation is that if we take the &lt;em&gt;inorder&lt;/em&gt;  node position as the
node &lt;code&gt;id&lt;/code&gt; we can store the tree in an array using the &lt;code&gt;id&lt;/code&gt; as the index. It can
then be observed that by a feat of &lt;em&gt;bit twiddling&lt;/em&gt; genius involving adding and
removing the least significant bit we can traverse &lt;em&gt;up&lt;/em&gt; the tree. Not only can
we traverse up the tree, at each node we can ascertain from which child we
arrived. See the above link for a more thorough explanation.&lt;/p&gt;

&lt;h2 id=&#34;fenwick-tree-in-go&#34;&gt;Fenwick Tree in Go&lt;/h2&gt;

&lt;p&gt;Without further ado&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Fenwick struct {
	tree []int
}

// NewFenwick: Build Fenwick tree to hold n values.
func NewFenwick(n int) *Fenwick {
	fen := &amp;amp;Fenwick{
		tree: make([]int, n),
	}
	return fen
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we abstract the data with a &lt;code&gt;struct&lt;/code&gt;. This prevents inadvertent
modification of the deceivingly subtle data that makes up the tree. Also, in my
opinion, it makes the slice access in later code cleaner since we need not use
pointer indirection to index into the array as is sometimes required &lt;code&gt;(*ptr)[i]&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Sum all values upto and including index.
func (fen *Fenwick) Sum(index int) int {
	sum := 0
	index++
	for index &amp;gt; 0 {
		sum += fen.tree[index-1]
		index -= lsb(index)
	}
	return sum
}

// lsb: Least Significant Bit
func lsb(x int) int {
	return x &amp;amp; -x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I would love to have gone straight from an understanding of this data structure
to the code, however this is not the case. I merely translated the C code from
&lt;a href=&#34;https://en.wikipedia.org/wiki/Fenwick_tree&#34;&gt;Wikipedia&lt;/a&gt; into Go code. Even then, it took a while for me to implement the
&lt;a href=&#34;https://github.com/tcharding/types/tree/master/trees/fenwick/fenwick-mul&#34;&gt;test&lt;/a&gt;
cases thoroughly enough that I understood what was going on.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Update using addition index by value.
func (fen *Fenwick) Update(index, value int) {
	index++
	for index &amp;lt;= fen.Size() {
		fen.tree[index-1] += value
		index += lsb(index)
	}
}

// Size: Number of values stored by tree.
func (fen *Fenwick) Size() int {
	return len(fen.tree)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All code available on &lt;a href=&#34;https://github.com/tcharding/types/tree/master/trees/fenwick/&#34;&gt;Github&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Fenwick trees are used, according to Wikipedia, in
&lt;a href=&#34;https://en.wikipedia.org/wiki/Arithmetic_coding&#34;&gt;arithmetic coding&lt;/a&gt;. They also
find use in counting integer inversion in an array.&lt;/p&gt;

&lt;p&gt;In conclusion, the Fenwick tree is a nifty little data structure. Hats off to its
creator.&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;notes&#34;&gt;Notes:&lt;/h4&gt;

&lt;p&gt;[1] Fenwick trees are not limited to integers and addition. Any binary operation may
be used. Any data type which implements the binary operation may be stored in the tree.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Graph Data Structures in Golang</title>
      <link>/blog/graph/</link>
      <pubDate>Thu, 05 Jan 2017 10:08:31 +1100</pubDate>
      
      <guid>/blog/graph/</guid>
      <description>&lt;p&gt;&lt;em&gt;&amp;hellip; understand just how astonishingly commonplace (and important) graph problems are&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;they should be part of every working programmer&amp;rsquo;s toolkit.&lt;/em&gt;
    - &lt;a href=&#34;http://steve-yegge.blogspot.com.au/2008/03/get-that-job-at-google.html&#34;&gt;Stevey&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The graph data structure is of high utility across the field of computer
science. Graph problems come in many shapes and sizes but once modeled can
typically be represented by a limited number of graph data type variants.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Writing a general purpose graph library is no mean feat. This post is not about creating a
general purpose graph library, if you are after such a library there is a nice
general purpose graph library written in Go by the
&lt;a href=&#34;https://github.com/gonum/graph&#34;&gt;gonum&lt;/a&gt; team.&lt;/p&gt;

&lt;p&gt;This post will lay the foundation for further exploration of graph algorithms in
Go. As such we will discuss the basic structure of various graphs. These details
will allow us to further build on these structures when faced with a particular
problem or when attempting to implement a particular well known graph algorithm.&lt;/p&gt;

&lt;h2 id=&#34;unweighted-graph&#34;&gt;Unweighted Graph&lt;/h2&gt;

&lt;p&gt;One of the most simple graphs is an unweighted graph with &lt;code&gt;N&lt;/code&gt; nodes labelled
&lt;code&gt;0..N-1&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Graph struct {
	NumNodes int
	Edges    [][]int
}

// NewGraph: Create graph with n nodes.
func NewGraph(n int) *Graph {
	return &amp;amp;Graph{
		NumNodes: n,
		Edges:    make([][]int, n),
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since the nodes are sequentially numbered we can store all edges in a slice
indexed by the source node. For an edge from &lt;code&gt;u&lt;/code&gt; to &lt;code&gt;v&lt;/code&gt; (&lt;code&gt;u -&amp;gt; v&lt;/code&gt;) we append &lt;code&gt;v&lt;/code&gt;
to the slice at &lt;code&gt;Edges[u]&lt;/code&gt;. We then have a slice of slices representing all
edges in the graph, with each slice &lt;code&gt;Edges[n]&lt;/code&gt; representing all nodes adjacent
to node labelled &lt;code&gt;n&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The graph thus far is &lt;em&gt;undirected&lt;/em&gt;, an edge &lt;code&gt;u -&amp;gt; v&lt;/code&gt; does not imply an edge &lt;code&gt;v
-&amp;gt; u&lt;/code&gt;. If the problem we are modelling requires an undirected graph it is simply a
matter of adding an edge &lt;code&gt;v -&amp;gt; u&lt;/code&gt; any time we add edge &lt;code&gt;u -&amp;gt; v&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// AddEdge: Add an edge from u to v.
func (g *Graph) AddEdge(u, v int) {
	g.Edges[u] = append(g.Edges[u], v)

	// For undirected graph add edge from v to u.
	// g.Edges[v] = append(g.Edges[v], u)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have the graph data structure implemented and are able to build a graph to
model the problem at hand. Depending on the problem we will need to access the
graph data in various ways. One common operation used, among other things, in
graph traversal is to iterate all nodes adjacent to node &lt;code&gt;n&lt;/code&gt;. This is easily
achieved with the current implementation by iterating the slice at
&lt;code&gt;Edges[n]&lt;/code&gt;. To process all edges in the graph one simply uses a nested loop to
iterate over &lt;code&gt;Edges&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (g *Graph) adjacentEdgesExample() {
	u := 0 // Example node label.

	fmt.Printf(&amp;quot;Printing all edges adjacent to Node: %d\n&amp;quot;, u)
	for _, v := range g.Edges[u] {
		// Edge exists from u to v.
		fmt.Printf(&amp;quot;Edge: %d -&amp;gt; %d\n&amp;quot;, u, v)
	}

	fmt.Println(&amp;quot;Printing all edges in graph.&amp;quot;)
	for u, adjacent := range g.Edges { // Nodes are labelled 0 to N-1.
		for _, v := range adjacent {
			// Edge exists from u to v.
			fmt.Printf(&amp;quot;Edge: %d -&amp;gt; %d\n&amp;quot;, u, v)
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;weighted-graph&#34;&gt;Weighted Graph&lt;/h2&gt;

&lt;p&gt;The next level of complexity that we may wish to add to a graph is edge
weight. This can be achieved by defining an &lt;code&gt;Edge&lt;/code&gt; type then storing all &lt;code&gt;Edge&lt;/code&gt;
instances in a slice in a similar fashion to the unweighted graph above. We
choose to store the &lt;code&gt;From&lt;/code&gt; node label in the &lt;code&gt;Edge&lt;/code&gt; type even though it is
redundant (since &lt;code&gt;Edges&lt;/code&gt; is inedexed by source node label). This often leads to
code that is easier to write and read. There is obviously a space cost to this
design choice.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Graph struct {
	NumNodes int
	Edges    [][]Edge
}

type Edge struct {
	From   int
	To     int
	Weight int
}

// NewGraph: Create graph with n nodes.
func NewGraph(n int) *Graph {
	return &amp;amp;Graph{
		NumNodes: n,
		Edges:    make([][]Edge, n),
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edges are added to the graph thus&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// AddEdge: Add an edge from u to v.
func (g *Graph) AddEdge(u, v, w int) {
	g.Edges[u] = append(g.Edges[u], Edge{From: u, To: v, Weight: w})

	// For undirected graph add edge from v to u.
	// g.Edges[v] = append(g.Edges[v], Edge{From: v, To: u, Weight: w})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And edges may be processed simply using slice iteration.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (g *Graph) adjacentEdgesExample() {
	u := 0 // Example node label.

	fmt.Printf(&amp;quot;Printing all edges adjacent to %d\n&amp;quot;, u)
	for _, e := range g.Edges[u] {
		fmt.Printf(&amp;quot;Edge: %d -&amp;gt; %d (%d)\n&amp;quot;, e.From, e.To, e.Weight)
	}

	fmt.Println(&amp;quot;Printing all edges in graph.&amp;quot;)
	for _, adjacent := range g.Edges {
		for _, e := range adjacent {
			fmt.Printf(&amp;quot;Edge: %d -&amp;gt; %d (%d)\n&amp;quot;, e.From, e.To, e.Weight)
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;arbitrary-node-labels&#34;&gt;Arbitrary Node Labels&lt;/h2&gt;

&lt;p&gt;Graph nodes will not always be labelled sequentially. If we require a graph with
arbitrary graph labels we will likely use a &lt;code&gt;map&lt;/code&gt; instead of a slice to store
edges. This provides flexibility at the cost of efficiency. Although map access
is said to be have constant time cost, I have found that on large data sets use
of maps is noticeably slower than use of slices. If efficiency is critical
you may like to consider remodelling your problem to use sequential node labels
if at all possible. The code using maps is similar to the code above, here we
will show an unweighted graph. Edge weights may be added as they were for
sequential node labels above.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Herein we use a type definition to abstract away the node label type.&lt;/strong&gt; Also we
now refer interchangeably to node label or node id.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type ID int

type Graph struct {
	Nodes map[ID]struct{}
	Edges map[ID]map[ID]struct{}
}

// NewGraph: Create graph.
func NewGraph() *Graph {
	return &amp;amp;Graph{
		Nodes: make(map[ID]struct{}),
		Edges: make(map[ID]map[ID]struct{}),
	}
}

// AddNode: Add node id to graph, return true if added (ID&#39;s are unique).
func (g *Graph) AddNode(id ID) bool {
	if _, ok := g.Nodes[id]; ok {
		return false
	}
	g.Nodes[id] = struct{}{}
	return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we add the constraint that node labels are unique. We use the Go idiom of
mapping an integer (node label) to an empty object &lt;code&gt;struct{}{}&lt;/code&gt;. While making the
code longer this makes explicit our intention that only the map key is of utility.&lt;/p&gt;

&lt;p&gt;Edges may be added thus.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// AddEdge: Add an edge from u to v.
func (g *Graph) AddEdge(u, v ID) {
	if _, ok := g.Nodes[u]; !ok {
		g.AddNode(u)
	}
	if _, ok := g.Nodes[v]; !ok {
		g.AddNode(v)
	}

	if _, ok := g.Edges[u]; !ok {
		g.Edges[u] = make(map[ID]struct{})
	}
	g.Edges[u][v] = struct{}{}

	// For undirected graph add edge from v to u.
	// if _, ok := g.Edges[v]; !ok {
	// 	g.Edges[v] = make(map[ID]struct{})
	// }
	// g.Edges[v][u] = struct{}{}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prior to adding an edge we access the inner map to verify that it is available
and create it if not. Once again we use an empty struct to make explicit that
the key value is the only value of utility. An undirected graph is created by
adding an edge in the reverse direction as previously discussed.&lt;/p&gt;

&lt;p&gt;Edge processing proceeds accordingly.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (g *Graph) adjacentEdgesExample() {
	u := ID(0) // example node ID.

	fmt.Printf(&amp;quot;Printing all edges adjacent to %d\n&amp;quot;, u)
	for v := range g.Edges[u] {
		// Edge exists from u to v.
		fmt.Printf(&amp;quot;Edge: %d -&amp;gt; %d\n&amp;quot;, u, v)
	}

	fmt.Println(&amp;quot;Printing all edges.&amp;quot;)
	for u, m := range g.Edges {
		for v := range m {
			// Edge exists from u to v.
			fmt.Printf(&amp;quot;Edge: %d -&amp;gt; %d\n&amp;quot;, u, v)
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Experienced Go programmers may pause at the use of a single variable &lt;code&gt;v&lt;/code&gt; above when
iterating a &lt;code&gt;map&lt;/code&gt;. Note that this refers to edge &lt;code&gt;v&lt;/code&gt; not the usual idiom &lt;code&gt;k, v :=
range m&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Graphs are an essential data structure. Implementing them in Go is both
enjoyable and educational. We have presented a simple method of implementing
graphs here but with just this much work we have a data structure which allows us to
do traversal, path finding, minimum spanning tree and much more.&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;bibliography&#34;&gt;Bibliography:&lt;/h4&gt;

&lt;p&gt;[Ski08] - &lt;strong&gt;The Algorithm Design Manual&lt;/strong&gt;, Steven S. Skiena&lt;br /&gt;
[CLRS09] - &lt;strong&gt;Introduction to Algorithms&lt;/strong&gt;, Thomas H.Cormen, Charles E. Leiserson,
Ronald L. Rivest, Clifford Stein&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>HackerRank: First milestone reached.</title>
      <link>/blog/hackerrank1/</link>
      <pubDate>Tue, 06 Dec 2016 11:14:39 +1100</pubDate>
      
      <guid>/blog/hackerrank1/</guid>
      <description>&lt;p&gt;&lt;em&gt;To appreciate programming as an intellectual activity in its own right &amp;hellip; you
must read and write computer programs - many of them.&lt;/em&gt;[ASS96]&lt;/p&gt;

&lt;p&gt;For the past nine weeks I have been working on programming questions at
&lt;a href=&#34;http://hackerrank.com&#34;&gt;HackerRank&lt;/a&gt; completing questions in the &amp;lsquo;practice area&amp;rsquo; i.e I have
not competed in any competitive programming competitions offered by the
site. Today I reached the first milestone I had set, namely, to get a top 1000
ranking (96th percentile) in the algorithms sub domain.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;hackerrank-com&#34;&gt;HackerRank.com&lt;/h3&gt;

&lt;p&gt;First a brief introduction to HackerRank (1). The site is one of many
competitive programming sites available currently. This is not, in any way, a
post about the merits of one site vs another. As such I do not intend to compare
HackerRank to any of its competitors.&lt;/p&gt;

&lt;p&gt;HackerRank is divided into two areas. One is the competitive programming
competitions and the other is the practice arena, an area of the site listing
multiple discrete programming questions divided into domains. This post is
concerning the practice arena. I will not be mentioning the competitions again
and may at times take the liberty of referring to the practice arena as &amp;lsquo;the
site&amp;rsquo; in general without further specification.&lt;/p&gt;

&lt;p&gt;The site (I did warn you), is divided into domains. The three &amp;lsquo;big&amp;rsquo; ones are
algorithms, artificial intelligence, and functional programming. Each domain is
separate in terms of score and rank. For each domain a user will have score (of
points for completed questions) and a rank (of all users of that domain). Each
domain is also divided into sub domains, such as sorting, graph theory
etc. Questions are rated easy, medium, hard etc and allotted a maximum
score. Partial solutions garner partial scores and multiple submissions are of
course allowed. Also statistics on success rates of completion are listed for
each question.&lt;/p&gt;

&lt;h3 id=&#34;statistics&#34;&gt;Statistics&lt;/h3&gt;

&lt;p&gt;I focused on the algorithms domain. I used Golang for all questions. As stated
above my first milestone was to get into the top 1000. During the nine weeks it
took me to do this I was aided by the texts listed in the bibliography
below. The primary aim of completing this milestone was to become a better
programmer and more specifically to become a better programmer in Go.&lt;/p&gt;

&lt;p&gt;Without further ado;&lt;/p&gt;

&lt;p&gt;150 hours over nine weeks&lt;br /&gt;
140 questions attempted&lt;br /&gt;
12 000 lines of code&lt;/p&gt;

&lt;h3 id=&#34;what-i-learned&#34;&gt;What I learned&lt;/h3&gt;

&lt;p&gt;All solutions must be complete i.e no libraries, so data structures and algorithms must be
written from scratch. This means that I learned thoroughly, for example, how to
implement and traverse a graph.&lt;/p&gt;

&lt;p&gt;The importance of data structures quickly becomes very clear, most used were; queue, stack, tree
(binary search tree, ordered statistical tree, n-ary tree), graph
(directed/undirected, weighted/unweighted).&lt;/p&gt;

&lt;p&gt;All questions read input from standard in and expect output on standard out. For
simplicity I tended to use &lt;code&gt;fmt.Fscanf&lt;/code&gt;. However on occasion IO
was found to be a bottleneck and I learned that &lt;code&gt;bufio.Scanner&lt;/code&gt; is faster.&lt;/p&gt;

&lt;p&gt;To test each solution I used a trick from Donovan and Kernighan [DK16]. In the
main file we declare two global variables &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt;. Also &lt;code&gt;main()&lt;/code&gt; is
simply a call to another function;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var (
	in  io.Reader = os.Stdin
	out io.Writer = os.Stdout
)

func main() {
	solve()
}

func solve() {
    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the test file, using &lt;a href=&#34;https://dave.cheney.net/2013/06/09/writing-table-driven-tests-in-go&#34;&gt;table driven testing&lt;/a&gt;, we override &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; in
order to supply test cases and check the output.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func Tes(t *testing.T) {
	var tests = []struct {
		input string
		want  string
	}{
	        {&amp;quot;1 2 3\n&amp;quot;, &amp;quot;10\n&amp;quot;},
    		{&amp;quot;5 6 7\n&amp;quot;, &amp;quot;11\n&amp;quot;},
	}

	for _, test := range tests {
		out = new(bytes.Buffer)
		in = bytes.NewBufferString(test.input)
		solve()

		if got := out.(*bytes.Buffer).String(); got != test.want {
			t.Errorf(&amp;quot;input: %s\n got: %s\n want: %s\n&amp;quot;,
				test.input, got, test.want)
		}
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Generally speaking the easy questions are solvable with an O(N^2) algorithm. Once
onto the medium questions however typically an O(NlogN) solution is
required. Often it suffices to look over the solution and change the algorithm
as needed but at times bench marking is helpful. I learned that Go&amp;rsquo;s built in
benchmark facilities are quick and easy to use and provided all one needs to get
the running times down on trickier questions.&lt;/p&gt;

&lt;p&gt;Bench marking can be implemented (assuming the question is coded as above) in
Golang by simply adding to a test file the following function;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func BenchmarkSolve(b *testing.B) {
	for i := 0; i &amp;lt; b.N; i++ {
		input := &amp;quot;1 2 3\n&amp;quot;
		out = new(bytes.Buffer)
		in = bytes.NewBufferString(input)
		solve()
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A Bench mark file can be produced with &lt;code&gt;$ go test -run=None -bench=Solve
-cpuprofile=cpu.out&lt;/code&gt;. One can then view the output using &lt;code&gt;go tool pprof -text
-nodecount=20 ./prog.test cpu.out&lt;/code&gt;. Where &lt;code&gt;prog.test&lt;/code&gt; is the executable that &lt;code&gt;go
test&lt;/code&gt; saves by default using the program name and the suffix &lt;code&gt;.test&lt;/code&gt;. The
&lt;code&gt;-run=None&lt;/code&gt; flag stops all other tests from being run during the bench mark.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;I found HackerRank to be well written, both the content and the site
operations. The questions were well paced and progressed in difficulty at a nice rate. There
are ample questions and a nice little dopamine release generated
by each score increase to keep you coming back. A text book or two on data
structures and algorithms is surely advisable. I found Golang to be very
suitable and pleasant to work with even though it can be verbose at times. If
you would like to deepen your understanding and quicken your algorithmic output
I can wholeheartedly recommend a few weeks spent on HackerRank.&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;notes&#34;&gt;Notes:&lt;/h4&gt;

&lt;p&gt;(1) &lt;strong&gt;I am not affiliated in any way with hackerrank.com&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;bibliography&#34;&gt;Bibliography:&lt;/h4&gt;

&lt;p&gt;[Ski08] - &lt;strong&gt;The Algorithm Design Manual&lt;/strong&gt;, Steven S. Skiena&lt;br /&gt;
[CLRS09] - &lt;strong&gt;Introduction to Algorithms&lt;/strong&gt;, Thomas H.Cormen, Charles E. Leiserson,
Ronald L. Rivest, Clifford Stein&lt;br /&gt;
[Mor] - &lt;strong&gt;Open Data Structures&lt;/strong&gt;, Pat Morin, Edition 0.1&lt;br /&gt;
[ASS96] - &lt;strong&gt;Structure and Interpretation of Computer Programs&lt;/strong&gt;, Harold Abelson
andGerald Jay Sussman with Julie Sussman.&lt;br /&gt;
[DK16] - &lt;strong&gt;The GO Programming Language&lt;/strong&gt;, Alan A. A. Donovan, Brian
W. Kernighan.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Heap Data Structure in Golang</title>
      <link>/blog/heap/</link>
      <pubDate>Thu, 10 Nov 2016 08:29:33 +1100</pubDate>
      
      <guid>/blog/heap/</guid>
      <description>&lt;p&gt;A heap is a data structure that supports the operations &lt;em&gt;insert&lt;/em&gt; and
&lt;em&gt;extract&lt;/em&gt;. Heaps typically come in two varieties, &lt;em&gt;min heap&lt;/em&gt; (for extracting the
minimum value) and &lt;em&gt;max heap&lt;/em&gt;. A heap is built using a binary tree where each
node is said to &lt;em&gt;dominate&lt;/em&gt; the nodes below it. The meaning of dominate depends
on the type of heap being implemented, for a &lt;em&gt;min heap&lt;/em&gt; the key of each node is
&lt;em&gt;less&lt;/em&gt; than the keys of both of child nodes.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;From here on, without loss of generality, we will talk about a heap of integers
(keys) ignoring satellite data that may or may not be associated with each
integer key. &lt;em&gt;Node&lt;/em&gt; and &lt;em&gt;key&lt;/em&gt; will therefore be used interchangeably.&lt;/p&gt;

&lt;p&gt;Like a binary search tree a heap can be implemented using a linked data
structure. There is however, a nifty method of implementing a heap using an
array, thereby reducing the memory requirements since there are no pointers to
store. We store the data as an array of keys and use the index of the keys to
implicitly satisfy the role of pointers.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The root node is stored at index 1 and all operations are 1-indexed&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;For node at index &lt;em&gt;k&lt;/em&gt; the left child can be found at index &lt;em&gt;2k&lt;/em&gt; and the
right child at index &lt;em&gt;2k + 1&lt;/em&gt;. (Quite clearly, checks must be made prior to
access that an index lies within the underlying array).&lt;/p&gt;

&lt;p&gt;One additional limitation must be placed on the tree, that it is &lt;em&gt;complete&lt;/em&gt;, i.e
all levels of the tree are full with the possible exception of the last level,
and if the last level is not full all nodes are as far to the left as
possible. This limitation results in an array with no holes in it.&lt;/p&gt;

&lt;p&gt;A heap as just described may be defined in Go as such;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type heap struct {
	xs []int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We wrap the array inside a struct to abstract the implementation and limit
access to the functions that we define. Care must be taken
to remember that the heap is 1-indexed.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (h *heap) Len() int {
	return len(h.xs) - 1 // heap is 1-indexed
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Insertion of a key into a heap can be achieved by adding the key to the end of
the underlying array. Whilst maintaining the structure of the heap this may
violate the &lt;em&gt;heap property&lt;/em&gt; of the parent of the newly inserted key, namely the
parent of the newly inserted key may not be dominant. The heap property for the
parent node can be restored by swapping the newly inserted child node with the
parent. This may in turn, result in the parent above violating the heap
property. We can continue this &lt;em&gt;bubbling&lt;/em&gt; of a node to successively higher nodes
until the heap property is restored. When swapping a node with the parent node
we need not consider the sibling node since if a node dominates the parent then
by definition it dominates the other sibling also.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Insert x into the heap
func (h *heap) Insert(x int) {
	(*h).xs = append(h.xs, x)
	h.bubbleUp(len(h.xs) - 1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that parenthesis are required to dereference the heap pointer in order to save the
return value of &lt;code&gt;append()&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (h *heap) bubbleUp(k int) {
	p, ok := parent(k)
	if !ok {
		return // k is root node
	}
	if h.xs[p] &amp;gt; h.xs[k] {
		h.xs[k], h.xs[p] = h.xs[p], h.xs[k]
		h.bubbleUp(p)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The function terminates when either the node is in place or it has reached the
root position.&lt;/p&gt;

&lt;p&gt;We define functions for manipulating indices as described above;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// get index of parent of node at index k
func parent(k int) (int, bool) {
	if k == 1 {
		return 0, false
	}
	return k / 2, true
}

// get index of left child of node at index k
func left(k int) int {
	return 2 * k
}

// get index of right child of node at index k
func right(k int) int {
	return 2*k + 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are now ready to extract the key for which our heap was designed (minimum
or maximum). This key is clearly at index 1, extracting this key however, leaves a hole which
must be filled. Swapping the last key of the array into the hole restores the
heap structure but once again may violate the &lt;em&gt;heap property&lt;/em&gt;. In a similar
fashion to insertion we can restore the heap property by bubbling this node down
the tree until it is either a leaf node or no longer violates the heap
property. In doing this we must consider both child nodes and swap any
non-dominant parent node with the child node that is &lt;em&gt;most&lt;/em&gt; dominant in order for
the heap property of these three nodes to be maintained.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ExtractMin: get minimum value of heap
// and remove value from heap
func (h *heap) ExtractMin() (int, bool) {
	if h.Len() == 0 {
		return 0, false
	}
	v := h.xs[1]
	h.xs[1] = h.xs[h.Len()]
	(*h).xs = h.xs[:h.Len()]
	h.bubbleDown(1)
	return v, true
}
    
func (h *heap) bubbleDown(k int) {
	min := k
	c := left(k)

	// find index of minimum value (k, k&#39;s left child, k&#39;s right child)
	for i := 0; i &amp;lt; 2; i++ {
		if (c + i) &amp;lt;= h.Len() {
			if h.xs[min] &amp;gt; h.xs[c+i] {
				min = c + i
			}
		}
	}
	if min != k {
		h.xs[k], h.xs[min] = h.xs[min], h.xs[k]
		h.bubbleDown(min)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Caution is again needed here since the array indexing and loop conditionals are
unusual because of the 1-indexing.&lt;/p&gt;

&lt;p&gt;See Github for complete
&lt;a href=&#34;https://github.com/tcharding/types/tree/master/heaps/minInt&#34;&gt;source code&lt;/a&gt; and tests.&lt;/p&gt;

&lt;h3 id=&#34;final-note&#34;&gt;Final Note&lt;/h3&gt;

&lt;p&gt;This implementation is based on the text &lt;em&gt;The Algorithm Design
Manual&lt;/em&gt; [Ski08]. In this, the author Steven S. Skiena makes an interesting
observation on the construction of a heap. At first glance one may think to
construct a heap by repeated calls to &lt;code&gt;insert()&lt;/code&gt;. Inserting into a heap (like
any balanced tree) takes O(log &lt;em&gt;n&lt;/em&gt;)), so heap construction in this manner has
worst case running time of O(&lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt;). We can do better, Skiena notes, if we
observe that a &lt;em&gt;full&lt;/em&gt;, &lt;em&gt;complete&lt;/em&gt; tree of &lt;em&gt;n&lt;/em&gt; nodes has &lt;em&gt;n/2&lt;/em&gt; leaf nodes. These
leaf nodes may be considered as sub-trees that maintain the heap property (since
they have only a single node). If then, we base a heap on any array we need only
&lt;em&gt;bubble up&lt;/em&gt; &lt;em&gt;n/2&lt;/em&gt; nodes in order to achieve a heap for which the heap property
holds. This still gives an &lt;em&gt;upper bound&lt;/em&gt; of O(&lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt;), however Skiena goes
on to show that this leads to a &lt;em&gt;not quite geometric&lt;/em&gt; series that he then
assures us quickly converges to linear. He does however, caution us that this
benefit may not be that useful if the algorithm we plan to use our heap for is
not governed by the construction (i.e heapsort will still run in O(&lt;em&gt;n&lt;/em&gt; log
&lt;em&gt;n&lt;/em&gt;)).&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;bibliography&#34;&gt;Bibliography:&lt;/h4&gt;

&lt;p&gt;[Ski08] - &lt;strong&gt;The Algorithm Design Manual&lt;/strong&gt;, Steven S. Skiena&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Deque Data Structure in Golang</title>
      <link>/blog/deque/</link>
      <pubDate>Tue, 08 Nov 2016 11:14:55 +1100</pubDate>
      
      <guid>/blog/deque/</guid>
      <description>&lt;p&gt;A deque is type of queue which enables adding and removing items from both
ends. Deque ends have such names as &lt;em&gt;left&lt;/em&gt;/&lt;em&gt;right&lt;/em&gt;, &lt;em&gt;front&lt;/em&gt;/&lt;em&gt;rear&lt;/em&gt; or, as we
will use here, &lt;em&gt;front&lt;/em&gt; and &lt;em&gt;back&lt;/em&gt;. The &lt;em&gt;add/remove&lt;/em&gt; operations on a deque are
typically called &lt;em&gt;enqueue&lt;/em&gt; and &lt;em&gt;dequeue&lt;/em&gt;. For ease of explanation but without loss
of generality, we limit discussion to a deque of integers.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;This gives us the following;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Deque struct {
	// Has unexported fields.
}

func (d *Deque) DequeueB() (int, bool)
func (d *Deque) DequeueF() (int, bool)
func (d *Deque) EnqueueB(x int)
func (d *Deque) EnqueueF(x int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One method of implementing a deque is to use two stacks, one representing the
front of the deque and the other representing the back of the deque. &lt;em&gt;Enqueueing&lt;/em&gt;
and &lt;em&gt;dequeueing&lt;/em&gt; then become simply a matter of &lt;em&gt;pushing&lt;/em&gt; or &lt;em&gt;popping&lt;/em&gt; to, or from, the
appropriate stack. . We will use a simple stack, supporting the operations push, pop, and
length. Previous blog &lt;a href=&#34;../stack&#34;&gt;post&lt;/a&gt; on implementing stacks in Golang.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type stack []int

// push a new integer onto the stack
func (s *stack) push(x int) {
	*s = append(*s, x)
}

// pop: remove and return top element of stack, return false if stack is empty
func (s *stack) pop() (int, bool) {
	if s.len() == 0 {
		return 0, false
	}

	i := len(*s) - 1
	x := (*s)[i]
	*s = (*s)[:i]

	return x, true
}

func (s *stack) len() int {
	return len(*s)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By now, the astute reader will be asking what happens when one stack becomes
empty and a further request comes to deque from that end. The solution to this
dilemma presents the only complexity in this implementation of a deque. Each
time an item is added to, or removed from, the deque we balance the two stacks to
maintain the invariant that while there are 2 or more items, each stack holds at
least one third as many items as the other. In code, that is;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// balance stacks if needed
func (d *Deque) balance() {
	small, big := order(&amp;amp;d.front, &amp;amp;d.back)
	if small.len() == 0 &amp;amp;&amp;amp; big.len() == 1 {
		return
	}
	if 3*d.front.len() &amp;lt; d.back.len() ||
		3*d.back.len() &amp;lt; d.front.len() {
		d.rebalance()
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;order()&lt;/code&gt; simply gives us the stacks back in order of size. Ignoring the
implementation of &lt;code&gt;rebalance()&lt;/code&gt; and time complexity for now, we have a deque that
maintains two &lt;em&gt;&amp;lsquo;balanced&amp;rsquo;&lt;/em&gt; stacks, one holding items for the front of the deque
and the other holding items for the back of the deque. We can enqueue and
dequeue from both ends.&lt;/p&gt;

&lt;h2 id=&#34;balancing-the-deque&#34;&gt;balancing the deque&lt;/h2&gt;

&lt;p&gt;Based on &lt;a href=&#34;http://opendatastructures.org&#34;&gt;Open Data Structures&lt;/a&gt; [Mor], we
maintain the invariant stated above (neither stack falls below 3x the size of
the other). Before giving the implementation let us discuss the running
time. Clearly if we are going to carry out some sequence of operations on
stacks, adding and/or removing some multiple of N, then we are going to be left
with running time of O(N). This would be disastrous since we call &lt;code&gt;balance()&lt;/code&gt; on
each &lt;em&gt;enqueue/dequeue&lt;/em&gt; operation. It turns out though, that while the worst case running
time is O(N), the amortized running time is O(1). Stated another way, for M
enqueue/dequeue operations we will have running time in the order of O(M).&lt;/p&gt;

&lt;p&gt;For those familiar with the running time complexity analysis of dynamic
arrays, the above statement will not come as a surprise. For a more complete
analysis see [Mor].&lt;/p&gt;

&lt;p&gt;One method of balancing the stacks is by way of a couple of additional temporary
stacks and a sequence of &lt;em&gt;push&lt;/em&gt; and &lt;em&gt;pop&lt;/em&gt; operations.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// rebalance stacks
func (d *Deque) rebalance() {
	small, big := order(&amp;amp;d.front, &amp;amp;d.back)
	half := (small.len() + big.len()) / 2
	tmpB := &amp;amp;stack{}
	tmpS := &amp;amp;stack{}
	mvN(tmpB, big, half) // store half of big
	mvAll(tmpS, small)   // store small
	mvAll(small, big)    // put bottom half of big onto small
	mvAll(small, tmpS)   // restore small
	mvAll(big, tmpB)     // restore big
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As mentioned previously, &lt;code&gt;order()&lt;/code&gt; simply gives us the stacks back in order of size, the other helper
functions are;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// mvN: move n items from dst and push to src
func mvN(dst, src *stack, n int) {
	for i := 0; i &amp;lt; n; i++ {
		x, _ := src.pop()
		dst.push(x)
	}
}

// mvAll: move all items from src to dst
func mvAll(dst, src *stack) {
	mvN(dst, src, src.len())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See Github for complete
&lt;a href=&#34;https://github.com/tcharding/types/tree/master/deques/twinStacks&#34;&gt;source code&lt;/a&gt; and tests.&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;bibliography&#34;&gt;Bibliography:&lt;/h4&gt;

&lt;p&gt;[Mor] - &lt;strong&gt;Open Data Structures&lt;/strong&gt;, Pat Morin, Edition 0.1&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Binary Search Tree in Golang</title>
      <link>/blog/bst/</link>
      <pubDate>Tue, 01 Nov 2016 11:37:27 +1100</pubDate>
      
      <guid>/blog/bst/</guid>
      <description>&lt;p&gt;A binary search tree (BST) is a binary tree where each node has a comparable key. As with
any tree, nodes may optionally contain satellite data.&lt;/p&gt;

&lt;p&gt;A BST can support many dynamic container operations, including search, minimum,
maximum, predecessor, successor, insert and delete. The defining feature of a
BST is that keys are maintained in an ordered fashion. This makes a BST a useful
data structure for implementing such things as ordered sets and bags.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;BST time complexity at worst case is O(&lt;em&gt;n&lt;/em&gt;), this occurs when the tree
is a linear chain of &lt;em&gt;n&lt;/em&gt; nodes. The expected height of a randomly built binary
tree is however &lt;em&gt;log n&lt;/em&gt;. This leads to the primary attraction of the BST, namely
that many operations have running time complexity of O(&lt;em&gt;log n&lt;/em&gt;). However, it is worth
keeping in mind the conditions that lead to worst case performance of a binary
tree. Building a tree from a sorted list of keys will produce worst case performance.&lt;/p&gt;

&lt;p&gt;The typical data structure used to implement a binary search tree found in the
literature as pseudo-code is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Node {
    integer key
    left Node
    right Node
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Translated into Go, with the addition of a parent node pointer to facilitate
more complex functionality, this becomes&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Node struct {
    key    int
    left   *Node
    right  *Node
    parent *Node
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In beginning our discussion on binary search trees we will ignore satellite
data. This is justified by the fact that a BST with an integer key alone is
useful for many operations coupled with the fact that the addition of satellite
data involves only minor changes the underlying types.&lt;/p&gt;

&lt;p&gt;If one proceeds, using the above node type, to implement typical BST operations,
it will not be long before a subtle problem arises. If one attempts to create an
empty tree by starting with a zero value node &lt;code&gt;var n Node&lt;/code&gt; the tree will contain
a node with the key value of &lt;code&gt;0&lt;/code&gt;. This is because the zero value of a node is
equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var n Node
    n.key = 0
    n.left = nil
    n.right = nil
    n.parent = nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This may not be the desired behaviour. One solution presents itself from
this (overly explicit) snippet. An empty tree can be created using a node pointer instead
of a node &lt;code&gt;var n *Node&lt;/code&gt;. Another solution, and the one we will use henceforth,
is to wrap a pointer to the root node within another data structure&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Tree struct {
    root *Node
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This allows for the zero value of a Tree to be useful &lt;code&gt;var t Tree&lt;/code&gt;. It also
abstracts the details of an empty tree away from the user.&lt;/p&gt;

&lt;h2 id=&#34;tree-traversal&#34;&gt;Tree Traversal&lt;/h2&gt;

&lt;p&gt;It is common to visit the nodes of a binary tree in one of three manners,
pre-order, in-order, or post-order. As the names suggest, these involve visiting
the node before, between, or after visiting it&amp;rsquo;s children. For a BST with
integer keys, it is often most useful to utilise in-order tree traversal (tree
walk). Such a tree traversal will give the keys in ascending sorted order.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Walk tree in order calling fn for each node
func (n *Node) inorder(fn func(n *Node)) {
	if n != nil {
		n.left.inorder(fn)
		fn(n)
		n.right.inorder(fn)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using this function, and Go&amp;rsquo;s support for closures, we can do things like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Flatten: return inorder slice of keys
func (t *Tree) Flatten() []int {
	var keys []int
	fn := func(n *Node) {
		keys = append(keys, n.key)
	}
	t.root.inorder(fn)
	return keys
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Related to tree traversal are the operations minimum and maximum. By the formal
definition for the relation between the keys of a BST&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The keys in a binary search tree are always sorted. Let x be a node in a binary
search tree. If y is a node in the left subtree of x, then y.key &amp;lt; x.key. If y
is a node in the right subtree of x, then y.key &amp;gt;= x.key&lt;/em&gt; [CLRS09]&lt;/p&gt;

&lt;p&gt;the node with the maximum key value will be found in the right-most leaf of the
tree&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Max: return maximum key from tree
func (t *Tree) Max() (int, error) {
	if t.root == nil {
		return 0, fmt.Errorf(&amp;quot;Max() called on empty tree&amp;quot;)
	}
	n := t.root.max()
	return n.key, nil
}

// max: find node with maximum key from tree rooted at n
func (n *Node) max() *Node {
	for n.right != nil {
		n = n.right
	}
	return n
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This shows one implication of using a separate Tree type. Methods may be
defined on Node types and/or on Tree types. For consistency Node methods will
return a node pointer giving us access to the node while Tree methods will
return the key value. Your millage may vary depending on the specific usage of
the tree. Minimum can be implemented in a similar fashion, for brevity it is
omitted but full source code can be found
&lt;a href=&#34;https://github.com/tcharding/types/tree/master/trees/bsts/intKey/unique&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;insertion-and-deletion&#34;&gt;Insertion and Deletion&lt;/h2&gt;

&lt;p&gt;This section follows the algorithmic design outlined in &lt;em&gt;Introduction to
Algorithms&lt;/em&gt; [CLRS09]&lt;/p&gt;

&lt;p&gt;Insertion into a BST is simply a matter of locating the correct position and
inserting a new node. First we will create a new node with the requisite key&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// newNode: create a new node from key
func newNode(key int) *Node {
	var n Node
	n.key = key
	return &amp;amp;n
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can insert the node into the tree&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Add key to tree
func (t *Tree) Add(key int) {
	n := newNode(key)
	t.insert(n)
}

// insert node n into t
func (t *Tree) insert(new *Node) {
	if t.root == nil {
		t.root = new
		return
	}
	// find position
	var p *Node = nil
	n := t.root
	for n != nil {
	    p = n
	    if new.key &amp;lt; n.key {
		    n = n.left
	    } else {
		    n = n.right
	    }
	}
	// insert node
	if new.key &amp;lt; p.key {
		p.left = new
	} else {
		p.right = new
	}
	new.parent = p
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thus far we have allowed multiple keys with the same value, this may or may not
be the required behaviour. It is however, trivial to transform one implementation to
the other, requiring only the addition of a check for equality between the new
nodes key and the current key&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    // ...
    for n != nil {
		p = n
		if new.key == n.key {
			return
		} else if new.key &amp;lt; n.key {
			n = n.left
		} else {
			n = n.right
		}
	}
    // ...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Detion is somewhat more involved. One way to think about it is as
follows; if a node has no children it can safely be removed. If a node has only
children in one subtree it can be replaced by that subtree. If a node has two
children it&amp;rsquo;s successor must be found and used to replace the deleted node. Only
the last of these three cases presents any complexity. Firstly, let us get the
successor node to a key value that exists within the tree&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Successor: find smallest key value larger than key
// panic if key not present, ok if found
func (t *Tree) Successor(key int) (int, bool) {
	n := t.root.find(key)
	if n == nil {
		panic(&amp;quot;Succesor() called with non-existant key&amp;quot;)
	}
	next := n.successor()
	if next == nil {
		return 0, false
	}
	return next.key, true
}

// find node by key
func (n *Node) find(key int) *Node {
	for n != nil &amp;amp;&amp;amp; key != n.key {
		if key &amp;lt; n.key {
			n = n.left
		} else {
			n = n.right
		}
	}
	return n
}

// successor: return node with smallest key larger than n.key
func (n *Node) successor() *Node {
	if n.right != nil {
		return n.right.min()
	}
	p := n.parent
	for p != nil &amp;amp;&amp;amp; n == p.right {
		n = p
		p = p.parent
	}
	return p
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now returning to deletion. As stated it is not overly complex to remove a node
with zero or one child(ren). Let us now focus on the case of a node (n) with two
children.&lt;/p&gt;

&lt;p&gt;This can be split into two cases; firstly if the successor (s) of n is the
direct right child of n (this implies s has a nil left child) then s can be
&amp;lsquo;transplanted&amp;rsquo; into the position of n.&lt;/p&gt;

&lt;p&gt;If the successor is further down the right subtree of n then it must be further
moved. We can modify the right right subtree of n by removing s and creating a
tree with s as the root and the reaming nodes as the right child of s. Since the
successor is by definition the smallest of n&amp;rsquo;s right children this new tree
maintains correct structure. This tree can then be transplanted into position.&lt;/p&gt;

&lt;p&gt;The code to transplant a node is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// transplant replaces subtree rooted at u with subtree rooted at v
func (t *Tree) transplant(u, v *Node) {
	if u.parent == nil {
		t.root = v
	} else if u == u.parent.left {
		u.parent.left = v
	} else {
		u.parent.right = v
	}
	if v != nil {
		v.parent = u.parent
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We then wrap the call to Delete (by key) method around a call to delete (by Node),
easing later additions to the Tree type.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Delete node with key from tree
// true if deleted
func (t *Tree) Delete(key int) bool {
	n := t.root.find(key)
	if n == nil {
		return false
	}
	t.delete(n)
	return true
}

func (t *Tree) delete(d *Node) {
	if d.left == nil {
		t.transplant(d, d.right)
	} else if d.right == nil {
		t.transplant(d, d.left)
	} else {
		n := d.right.min()
		if n.parent != d {
			t.transplant(n, n.right)
			n.right = d.right
			n.right.parent = n
		}
		t.transplant(d, n)
		n.left = d.left
		n.left.parent = n
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Often when thinking about algoritms involving binary trees, recursive solutions
come to mind. And while many binary tree operations can be implemented in a
recursive manner some can be re-written in an iterative manner. Some however
cannot (e.g in-order tree walk). We must be careful to understand the
implications of calling recursive functions in a language that does not
implement tail call optimization. It is therefore sometimes prudent to consider an
iterative implementation as well as recursive. Here is one such function&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// elem: true if node with key exists in tree rooted at node n, recursive version
func (n *Node) elem(key int) bool {
	if n == nil {
		return false
	}
	if key == n.key {
		return true
	} else if key &amp;lt; n.key {
		return n.left.elem(key)
	}
	return n.right.elem(key)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And an iterative implementation&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// elem: true if node with key exists in tree rooted at node n, iterative version
func (n *Node) elem(key int) bool {
	found := false
	for {
		if n == nil {
			break // found = false
		}
		if n.key == key {
			found = true
			break
		}
		if key &amp;lt; n.key {
			n = n.left
		} else {
			n = n.right
		}
	}
	return found
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For full source code including additional operations (sum, size, height etc) see
&lt;a href=&#34;https://github.com/tcharding/types/tree/master/trees/bsts/intKey/unique&#34;&gt;github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As a final note, binary search trees can take many forms. If you have any
ideas on how I can better make use of search trees, or any comments at all,
please feel free to email me or submit a pull request.&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;bibliography&#34;&gt;Bibliography:&lt;/h4&gt;

&lt;p&gt;[Ski08] - &lt;strong&gt;The Algorithm Design Manual&lt;/strong&gt;, Steven S. Skiena&lt;br /&gt;
[CLRS09] - &lt;strong&gt;Introduction to Algorithms&lt;/strong&gt;, Thomas H.Cormen, Charles E. Leiserson,
Ronald L. Rivest, Clifford Stein&lt;br /&gt;
[Mor] - &lt;strong&gt;Open Data Structures&lt;/strong&gt;, Pat Morin, Edition 0.1&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Bag Data Structure in Golang</title>
      <link>/blog/bag/</link>
      <pubDate>Wed, 26 Oct 2016 10:49:04 +1100</pubDate>
      
      <guid>/blog/bag/</guid>
      <description>&lt;p&gt;A bag is a container of non-unique items. Bags are defined by the following
operations &lt;em&gt;Length&lt;/em&gt;, &lt;em&gt;Add&lt;/em&gt;, &lt;em&gt;Delete&lt;/em&gt; and &lt;em&gt;Find&lt;/em&gt;. Bags often also need to support
&lt;em&gt;FindAll&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Bags can be ordered or un-ordered. This post will be discussing un-ordered
bags.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Bags are useful when one needs to store a bunch of things and later check
if a certain thing is present. For example, storing the characters of a string
(and perhaps, the frequency count).&lt;/p&gt;

&lt;p&gt;A bag can be easily implemented in Go using a map.&lt;/p&gt;

&lt;h2 id=&#34;bag-of-integers&#34;&gt;bag of integers&lt;/h2&gt;

&lt;p&gt;For the sake of simplicity, we will first cover a bag of integers, then move
onto a bag of characters (including some useful functions on such a bag).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package bag

type count int

type Bag map[int]count

func (b *Bag) Len() int {
	sum := 0
	for _, v := range *b {
		sum += int(v)
	}
	return sum
}

func (b *Bag) Add(x int) {
	(*b)[x]++
}

func (b *Bag) Delete(x int) {
	_, ok := (*b)[x]
	if ok {
		(*b)[x]--
	}
}

func (b *Bag) Find(x int) (int, bool) {
	count, ok := (*b)[x]
	return int(count), ok
}

func (b *Bag) FindAll(x int) (int, bool) {
	return b.Find(x) // not useful for this implementation
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then use our bag of integers like this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func fn() {
    bag := make(Bag)

	// add some values to bag
	for i := 0; i &amp;lt; 5; i++ {
		bag.Add(i)
    }

    // check if we have a &#39;2&#39;
    x, ok := bag.Find(2)  // x = 1 (one &#39;2&#39; in bag), ok = true

    // check if we have a &#39;10&#39;
    x, ok = bag.Find(10)  // ok = false (no &#39;10&#39; in bag)

    // add a second &#39;2&#39; and check we now have two of them in bag 
    bag.Add(2)
    x, ok := bag.Find(2)  // x = 2 (two 2&#39;s in bag), ok = true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;bag-of-bytes&#34;&gt;bag of bytes&lt;/h2&gt;

&lt;p&gt;A bag of bytes can be used to store such things as byte values for characters
encoded using ASCII. This bag would not be very useful for storing text written
in Greek but would be useful for some cryptography tasks.&lt;/p&gt;

&lt;p&gt;The basic operations are similar to the above, except of course we replace
occurences of &lt;code&gt;int&lt;/code&gt; with &lt;code&gt;byte&lt;/code&gt;. Also we add a helper function to create a bag
from a string (ASCII values only remember).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Bag map[byte]int

func makeBag(s string) Bag {
	bag := make(Bag)
	for i := 0; i &amp;lt; len(s); i++ {
		bag.Add(s[i])
	}
	return bag
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then write some other functions to operate on this bag&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (b *Bag) difference(c Bag) Bag {
	bag := make(Bag)
	for k, vb := range *b {
		vc, ok := c[k]
		if ok {
			if vb &amp;gt; vc {
				bag[k] = vb - vc
			}
		} else {
			bag[k] = vb
		}
	}
	return bag
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similarly, one can implement union, and intersection in the above manner. See
Github for complete
&lt;a href=&#34;https://github.com/tcharding/types/tree/master/bags&#34;&gt;source code&lt;/a&gt; and tests.&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;bibliography&#34;&gt;Bibliography:&lt;/h4&gt;

&lt;p&gt;[Ski08] - &lt;strong&gt;The Algorithm Design Manual&lt;/strong&gt;, Steven S. Skiena&lt;br /&gt;
[CLRS09] - &lt;strong&gt;Introduction to Algorithms&lt;/strong&gt;, Thomas H.Cormen, Charles E. Leiserson,
Ronald L. Rivest, Clifford Stein&lt;br /&gt;
[Mor] - &lt;strong&gt;Open Data Structures&lt;/strong&gt;, Pat Morin, Edition 0.1&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Queue Data Structure in Golang</title>
      <link>/blog/queue/</link>
      <pubDate>Wed, 26 Oct 2016 09:54:21 +1100</pubDate>
      
      <guid>/blog/queue/</guid>
      <description>&lt;p&gt;A queue is a container that supports retrieval by first-in, first-out (FIFO)
order. The &lt;em&gt;get&lt;/em&gt; and &lt;em&gt;put&lt;/em&gt; operations for a queue are usually called &lt;em&gt;enqueue&lt;/em&gt; and
&lt;em&gt;dequeue&lt;/em&gt;, other operations may include &lt;em&gt;isEmpty&lt;/em&gt;. A full description of
queues can be found online &lt;a href=&#34;http://opendatastructures.org&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Queue&amp;rsquo;s minimise the maximum time spent waiting, however the average wait time
will be the same whether a LIFO or a FIFO is used.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;A queue can be easily implemented in Go using slices.&lt;/p&gt;

&lt;h2 id=&#34;queue-of-integers&#34;&gt;queue of integers&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;package queue

type Queue []int

func (q *Queue) Enqueue(x int) {
	*q = append(*q, x)
}

func (q *Queue) Dequeue() (int, bool) {
	if q.isEmpty() {
		return 0, false
	}

	x := (*q)[0]
	*q = (*q)[1:]
	return x, true
}

func (q *Queue) isEmpty() bool {
	return len(*q) == 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then use our queue of integers like this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func fn() {
    var q Queue

    q.Enque(1)
    q.Enque(2)
    q.Enque(3)

    x := q.Dequeue()  // x = 1
    x = q.Dequeue()   // x = 2
    x = q.Dequeue()   // x = 3
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;queue-of-structs&#34;&gt;queue of structs&lt;/h2&gt;

&lt;p&gt;Today I found a nice implementation of a Queue in the
&lt;a href=&#34;https://github.com/gonum/graph/blob/master/internal/linear/linear.go&#34;&gt;graph&lt;/a&gt;
package by the people at &lt;a href=&#34;https://github.com/gonum&#34;&gt;Gonum&lt;/a&gt;. I have stripped it
down to a queue of structs&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Queue implements a FIFO queue.
type Queue struct {
	head int
	data []item
}

// Item: real implementation would have something useful here.
type item struct {
	data string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;head&lt;/code&gt; is the index of the head of the queue. Length of the queue is then the
length of the data slice less the index of the head item.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Len returns the number of items in the queue.
func (q *Queue) Len() int { return len(q.data) - q.head }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to reuse the underlying array, when an item is enqueued, if there is
room at the front of the queue then we copy the current queue contents back to
the start of the array.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Enqueue adds the node n to the back of the queue.
func (q *Queue) Enqueue(n item) {
	if len(q.data) == cap(q.data) &amp;amp;&amp;amp; q.head &amp;gt; 0 {
		ln := q.Len()
		copy(q.data, q.data[q.head:])
		q.head = 0
		q.data = append(q.data[:ln], n)
	} else {
		q.data = append(q.data, n)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that arguments to copy may be overlapping, Go&amp;rsquo;s built in &lt;code&gt;copy&lt;/code&gt; allows
this. This is a nice efficiency tweak over the simple implementation given at
the start of this post. We now reduce the number of times that a new underlying
array is created.&lt;/p&gt;

&lt;p&gt;The memory usage of this implementation is quite different from the simple
queue. Like as is often the case with data structures, different data structures
may perform differently under different workloads, one is not necessarily better
than another.&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;bibliography&#34;&gt;Bibliography:&lt;/h4&gt;

&lt;p&gt;[Ski08] - &lt;strong&gt;The Algorithm Design Manual&lt;/strong&gt;, Steven S. Skiena&lt;br /&gt;
[CLRS09] - &lt;strong&gt;Introduction to Algorithms&lt;/strong&gt;, Thomas H.Cormen, Charles E. Leiserson,
Ronald L. Rivest, Clifford Stein&lt;br /&gt;
[Mor] - &lt;strong&gt;Open Data Structures&lt;/strong&gt;, Pat Morin, Edition 0.1&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>