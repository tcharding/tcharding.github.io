<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tobin Harding</title>
    <link>/index.xml</link>
    <description>Recent content on Tobin Harding</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 26 Oct 2016 10:49:04 +1100</lastBuildDate>
    <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Bag Data Structure in Golang</title>
      <link>/blog/bag/</link>
      <pubDate>Wed, 26 Oct 2016 10:49:04 +1100</pubDate>
      
      <guid>/blog/bag/</guid>
      <description>&lt;p&gt;A bag is a container of non-unique items. Bags are defined by the following
operations &lt;em&gt;Length&lt;/em&gt;, &lt;em&gt;Add&lt;/em&gt;, &lt;em&gt;Delete&lt;/em&gt; and &lt;em&gt;Find&lt;/em&gt;. Bags often also need to support
&lt;em&gt;FindAll&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Bags can be ordered or un-ordered. This post will be discussing un-ordered
bags.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Bags are useful when one needs to store a bunch of things and later check
if a certain thing is present. For example, storing the characters of a string
(and perhaps, the frequency count).&lt;/p&gt;

&lt;p&gt;A bag can be easily implemented in Go using a map.&lt;/p&gt;

&lt;h2 id=&#34;bag-of-integers&#34;&gt;bag of integers&lt;/h2&gt;

&lt;p&gt;For the sake of simplicity, we will first cover a bag of integers, then move
onto a bag of characters (including some useful functions on such a bag).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package bag

type count int

type Bag map[int]count

func (b *Bag) Len() int {
	sum := 0
	for _, v := range *b {
		sum += int(v)
	}
	return sum
}

func (b *Bag) Add(x int) {
	(*b)[x]++
}

func (b *Bag) Delete(x int) {
	_, ok := (*b)[x]
	if ok {
		(*b)[x]--
	}
}

func (b *Bag) Find(x int) (int, bool) {
	count, ok := (*b)[x]
	return int(count), ok
}

func (b *Bag) FindAll(x int) (int, bool) {
	return b.Find(x) // not useful for this implementation
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then use our bag of integers like this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func fn() {
    bag := make(Bag)

	// add some values to bag
	for i := 0; i &amp;lt; 5; i++ {
		bag.Add(i)
    }

    // check if we have a &#39;2&#39;
    x, ok := bag.Find(2)  // x = 1 (one &#39;2&#39; in bag), ok = true

    // check if we have a &#39;10&#39;
    x, ok = bag.Find(10)  // ok = false (no &#39;10&#39; in bag)

    // add a second &#39;2&#39; and check we now have two of them in bag 
    bag.Add(2)
    x, ok := bag.Find(2)  // x = 2 (two 2&#39;s in bag), ok = true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;bag-of-bytes&#34;&gt;bag of bytes&lt;/h2&gt;

&lt;p&gt;A bag of bytes can be used to store such things as byte values for characters
encoded using ASCII. This bag would not be very useful for storing text written
in Greek but would be useful for some cryptography tasks.&lt;/p&gt;

&lt;p&gt;The basic operations are similar to the above, except of course we replace
occurences of &lt;code&gt;int&lt;/code&gt; with &lt;code&gt;byte&lt;/code&gt;. Also we add a helper function to create a bag
from a string (ASCII values only remember).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Bag map[byte]int

func makeBag(s string) Bag {
	bag := make(Bag)
	for i := 0; i &amp;lt; len(s); i++ {
		bag.Add(s[i])
	}
	return bag
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then write some other functions to operate on this bag&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (b *Bag) difference(c Bag) Bag {
	bag := make(Bag)
	for k, vb := range *b {
		vc, ok := c[k]
		if ok {
			if vb &amp;gt; vc {
				bag[k] = vb - vc
			}
		} else {
			bag[k] = vb
		}
	}
	return bag
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similarly, one can implement union, and intersection in the above manner. See
Github for complete
&lt;a href=&#34;https://github.com/tcharding/types/tree/master/bags&#34;&gt;source code&lt;/a&gt; and tests.&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;bibliography&#34;&gt;Bibliography:&lt;/h4&gt;

&lt;p&gt;[Ski08] - &lt;strong&gt;The Algorithm Design Manual&lt;/strong&gt;, Steven S. Skiena&lt;br /&gt;
[Cor09] - &lt;strong&gt;Introduction to Algorithms&lt;/strong&gt;, Thomas H. Cormen, Charles E. Leiserson,
Ronald L. Rivest, Clifford Stein&lt;br /&gt;
[Mor] - &lt;strong&gt;Open Data Structures&lt;/strong&gt;, Pat Morin, Edition 0.1&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Queue Data Structure in Golang</title>
      <link>/blog/queue/</link>
      <pubDate>Wed, 26 Oct 2016 09:54:21 +1100</pubDate>
      
      <guid>/blog/queue/</guid>
      <description>&lt;p&gt;A queue is a container that supports retrieval by first-in, first-out (FIFO)
order. The &lt;em&gt;get&lt;/em&gt; and &lt;em&gt;put&lt;/em&gt; operations for a queue are usually called &lt;em&gt;enqueue&lt;/em&gt; and
&lt;em&gt;dequeue&lt;/em&gt;, other operations may include &lt;em&gt;isEmpty&lt;/em&gt;. A full description of
queues can be found online &lt;a href=&#34;http://opendatastructures.org&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Queue&amp;rsquo;s minimise the maximum time spent waiting, however the average wait time
will be the same whether a LIFO or a FIFO is used.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;A queue can be easily implemented in Go using slices.&lt;/p&gt;

&lt;h2 id=&#34;queue-of-integers&#34;&gt;queue of integers&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;package queue

type Queue []int

func (q *Queue) Enqueue(x int) {
	*q = append(*q, x)
}

func (q *Queue) Dequeue() (int, bool) {
	if q.isEmpty() {
		return 0, false
	}

	x := (*q)[0]
	*q = (*q)[1:]
	return x, true
}

func (q *Queue) isEmpty() bool {
	return len(*q) == 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then use our queue of integers like this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func fn() {
    var q Queue

    q.Enque(1)
    q.Enque(2)
    q.Enque(3)

    x := q.Dequeue()  // x = 1
    x = q.Dequeue()   // x = 2
    x = q.Dequeue()   // x = 3
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;bibliography&#34;&gt;Bibliography:&lt;/h4&gt;

&lt;p&gt;[Ski08] - &lt;strong&gt;The Algorithm Design Manual&lt;/strong&gt;, Steven S. Skiena&lt;br /&gt;
[Cor09] - &lt;strong&gt;Introduction to Algorithms&lt;/strong&gt;, Thomas H. Cormen, Charles E. Leiserson,
Ronald L. Rivest, Clifford Stein&lt;br /&gt;
[Mor] - &lt;strong&gt;Open Data Structures&lt;/strong&gt;, Pat Morin, Edition 0.1&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Stack Data Structure in Golang</title>
      <link>/blog/stack/</link>
      <pubDate>Mon, 17 Oct 2016 08:28:17 +1100</pubDate>
      
      <guid>/blog/stack/</guid>
      <description>&lt;p&gt;A stack is a container that supports retrieval by last-in, first-out (LIFO)
order. The &lt;em&gt;get&lt;/em&gt; and &lt;em&gt;put&lt;/em&gt; operations for stacks are usually called &lt;em&gt;push&lt;/em&gt; and
&lt;em&gt;pop&lt;/em&gt;, other operations may include &lt;em&gt;peek&lt;/em&gt; and &lt;em&gt;isEmpty&lt;/em&gt;. A full description of
stacks can be found online &lt;a href=&#34;http://opendatastructures.org&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Stacks are simple to implement and very efficient. For this reason, stacks are
probably the right container to use when retrieval order doesn&amp;rsquo;t matter [Ski08]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A stack can be easily implemented in Go using slices.&lt;/p&gt;

&lt;h2 id=&#34;stack-of-integers&#34;&gt;stack of integers&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;// stack of integers
package stack

type Stack []int

// IsEmpty: check if stack is empty
func (s *Stack) IsEmpty() bool {
	return len(*s) == 0
}

// Push a new integer onto the stack
func (s *Stack) Push(x int) {
	*s = append(*s, x)
}

// Pop: remove and return top element of stack, return false if stack is empty
func (s *Stack) Pop() (int, bool) {
	if s.IsEmpty() {
		return 0, false
	}

	i := len(*s) - 1
	x := (*s)[i]
	*s = (*s)[:i]

	return x, true
}

// Peek: return top element of stack, return false if stack is empty
func (s *Stack) Peek() (int, bool) {
	if s.IsEmpty() {
		return 0, false
	}

	i := len(*s) - 1
	x := (*s)[i]

	return x, true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then use our stack of integers like this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func fn() {
    var stack Stack

    stack.Push(1)
    stack.Push(2)
    stack.Push(3)

    x := stack.Peek()  // x = 3
    x = stack.Pop()    // x = 3
    x = stack.Peek()   // x = 2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is trivial to replace integers with any other type
(&lt;a href=&#34;https://github.com/tcharding/types/tree/master/stacks/string&#34;&gt;string&lt;/a&gt;,
struct, etc).&lt;/p&gt;

&lt;h2 id=&#34;stack-of-anything&#34;&gt;stack of anything&lt;/h2&gt;

&lt;p&gt;One downside to the above method is that a new stack needs to be written for
each data type. An alternative is to use the empty interface to allow stacks of
anything.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// All types satisfy the empty interface, so we can store anything here.
type Stack []interface{}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then any time we pop or peek at an item from the stack we use a type
assertion.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var stack Stack
stack.Push(&amp;quot;this&amp;quot;)

item := stack.Pop()
fmt.Printf(&amp;quot;%s\n&amp;quot;, item.(string))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This comes with the usual warnings that using the empty type interface reduces
the ability of the compiler to catch type errors, one of the benefits of using a
strongly typed language.&lt;/p&gt;

&lt;p&gt;Full source code is available &lt;a href=&#34;https://github.com/tcharding/types/tree/master/stacks&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Also Douglas Hall has done a nice stack implementation using linked lists instead of
slices. You can find his gist &lt;a href=&#34;https://gist.github.com/bemasher/1777766&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;bibliography&#34;&gt;Bibliography:&lt;/h4&gt;

&lt;p&gt;[Ski08] - &lt;strong&gt;The Algorithm Design Manual&lt;/strong&gt;, Steven S. Skiena&lt;br /&gt;
[Cor09] - &lt;strong&gt;Introduction to Algorithms&lt;/strong&gt;, Thomas H. Cormen, Charles E. Leiserson,
Ronald L. Rivest, Clifford Stein&lt;br /&gt;
[Mor] - &lt;strong&gt;Open Data Structures&lt;/strong&gt;, Pat Morin, Edition 0.1&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Reading List</title>
      <link>/reading-list/</link>
      <pubDate>Sat, 15 Oct 2016 14:17:43 +1100</pubDate>
      
      <guid>/reading-list/</guid>
      <description>

&lt;p&gt;Past, current, and future. List is in approximate reverse chronological order.&lt;/p&gt;

&lt;h1 id=&#34;future&#34;&gt;Future&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Introduction to Graph Theory&lt;/strong&gt;
Richard J. Trudeau&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Linear Algebra and its Applications&lt;/strong&gt;
Gilbert Strang&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Flatland: A Romance of Many Dimensions&lt;/strong&gt;
Edwin Abbott Abbott&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Alchemist&lt;/strong&gt;
Paulo Coelho&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Gödel, Escher, Bach: an Eternal Golden Braid&lt;/strong&gt;
Douglas R. Hofstadter&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Peopleware&lt;/strong&gt; Productive Projects and Teams -
Tom DeMarco and Timothy Lister&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Mythical Man-Month&lt;/strong&gt;
Frederick P. Brooks, Jr.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;An Introduction to Functional Programming Systems Using Haskell&lt;/strong&gt;
A J T Davie&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mastering Regular Expressions&lt;/strong&gt;
Jeffrey E.F. Friedl&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hackers Delight&lt;/strong&gt;
Henry S. Warren, Jr.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Programming Pearls&lt;/strong&gt;
Jon Bently&lt;/p&gt;

&lt;h1 id=&#34;current&#34;&gt;Current&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;The Go Programming Language&lt;/strong&gt;
Alan A. A. Donovan, Brian W. Kernighan&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Discrete and Combinatorial Mathematics&lt;/strong&gt;
Ralph P. Grimaldi&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Open Data Structures&lt;/strong&gt;
Pat Morin&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Introduction to Algorithms&lt;/strong&gt;
Thomas H. Cormen, Charles C. Leiserson, Ronald L. Rivest, Clifford Stein&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Algorithm Design Manual&lt;/strong&gt;
Steven S Skiena&lt;/p&gt;

&lt;h1 id=&#34;past&#34;&gt;Past&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Apprenticeship Patterns&lt;/strong&gt; Guidance for the Aspiring Software Craftsman -
David H. Hoover and Adewale Oshineye &lt;em&gt;(a,-)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Real World Haskell&lt;/strong&gt;
Bryan O&amp;rsquo;Sullivan, John Goerzen and Don Stewart &lt;em&gt;(s,s)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Learn You a Haskell For Great Good&lt;/strong&gt;
Miran Lipovaca &lt;em&gt;(m,m)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Structure and Interpretation of Computer Programs&lt;/strong&gt;
Harold Abelson, Gerald Jay Sussman, Julie Sussman &lt;em&gt;(m,m)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Scheme Programming Language&lt;/strong&gt;
R. Kent Dybvig &lt;em&gt;(m,m)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Little Schemer&lt;/strong&gt;
Daniel P. Friedman, Matthias Felleisen &lt;em&gt;(a,a)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ARM Assembly Language&lt;/strong&gt;
William Hohl &lt;em&gt;(a,m)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Essential Linux Device Drivers&lt;/strong&gt;
Sreekrishnan Venkateswaran &lt;em&gt;(a,-)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Linux Device Drivers&lt;/strong&gt;
Jonathan Corbet, Alessandro Rubini, Greg Kroah-Hartman &lt;em&gt;(a,a)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Linux Kernel Develop&lt;/strong&gt;
Robert Love &lt;em&gt;(a,-)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Linux Programming Interface&lt;/strong&gt;
Michael Kerrisk &lt;em&gt;(m,m)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Programming the World Wide&lt;/strong&gt;
Rebert W. Sebesta &lt;em&gt;(a,-)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Applied Cryptography&lt;/strong&gt;
Bruce Schneier &lt;em&gt;(a,-)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Python Essential Reference&lt;/strong&gt;
David M. Beazley &lt;em&gt;(m,-)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Clean Code, A Handbook of Agile Software Craftsmanship&lt;/strong&gt;
Robert C. Martin &lt;em&gt;(a,-)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Python the Hard Way&lt;/strong&gt;
Zed A. Shaw &lt;em&gt;(a,a)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UNIX Network Programming&lt;/strong&gt;
W. Richard Stevens, Bill Fenner, Andrew M. Rudoff &lt;em&gt;(a,a)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Advanced Programming in the UNIX Environment&lt;/strong&gt;
W. Richard Stevens, Stephen A. Rago &lt;em&gt;(a,a)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UNIX Systems Programming&lt;/strong&gt;
Kay A. Robbins, Steven Robbins &lt;em&gt;(a,m)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Intermediate Perl&lt;/strong&gt;
Randal L. Schwartz, brian d foy, Tom Phoenix &lt;em&gt;(a,a)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Learning Perl&lt;/strong&gt;
Randal L. Schwartz, brian d foy, Tom Phoenix &lt;em&gt;(a,a)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Beginning Linux Programming&lt;/strong&gt;
Neil Matthew, Richard Stones &lt;em&gt;(a,-)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Version Control with Git&lt;/strong&gt;
Jon Loeliger, Matthew McCullough &lt;em&gt;(a,-)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Pragmatic Programmer&lt;/strong&gt;
Andrew Hunt, David Thomas &lt;em&gt;(a,-)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Art of UNIX Programming&lt;/strong&gt;
Eric S. Raymond &lt;em&gt;(a,-)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Expert C Programming, Deep C Secrets&lt;/strong&gt;
Peter Van Der Linden &lt;em&gt;(a,-)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Practice of Programming&lt;/strong&gt;
Brian W. Kernighan, Rob Pike &lt;em&gt;(a,-)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How Linux Works&lt;/strong&gt;
Brian Ward &lt;em&gt;(a,-)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Learning GNU Emacs&lt;/strong&gt;
Debra Cameron, James Elliott, Marc Loy, Eric Raymond, Bill Rosenblatt &lt;em&gt;(a,-)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Art of Computer Programming (volume 2)&lt;/strong&gt; Seminumerical Algorithms -
Donald E. Knuth &lt;em&gt;(m,-)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Art of Computer Programming (volume 1)&lt;/strong&gt; Fundamental Algorithms -
Donald E. Knuth &lt;em&gt;(a,-)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Command Line Kung Foo&lt;/strong&gt;
Jason Cannon &lt;em&gt;(a,-)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Linux Shell Scripting with Bash&lt;/strong&gt;
Ken O. Burtch &lt;em&gt;(a,-)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;From Bash to Z Shell&lt;/strong&gt; Conquering the Command -
Oliver Kiddle, Jerry Peek, Peter Stephenson &lt;em&gt;(a,-)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Computer Networks&lt;/strong&gt; A Systems Approach -
Larry L. Peterson, Bruce S. Davie &lt;em&gt;(a,-)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A Concise Introduction to Pure Mathematics&lt;/strong&gt;
Martin Liebeck &lt;em&gt;(m,m)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Computer Organization and Design&lt;/strong&gt;
David A. Patterson, John L Hennessy &lt;em&gt;(a,-)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Operating System Concepts&lt;/strong&gt;
Abraham Silberschatz, Peter Baer Galvin, Greg Cagne &lt;em&gt;(a,-)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The C Programming Language&lt;/strong&gt;
Brian W. Kernighan, Dennis Ritchie &lt;em&gt;(a,a)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Past reading entries are suffixed with code representing level of
completion. First character representing amount of
text read. Second character representing amount of exercises
completed.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Key:&lt;/strong&gt; &lt;em&gt;(x,x)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;s = some&lt;br /&gt;
m = most&lt;br /&gt;
a = all&lt;br /&gt;
- = not applicable (i.e no exercises in text)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>initial commit</title>
      <link>/blog/initial-commit/</link>
      <pubDate>Tue, 11 Oct 2016 22:10:57 +1100</pubDate>
      
      <guid>/blog/initial-commit/</guid>
      <description>&lt;p&gt;According to &lt;strong&gt;Apprenticeship Patterns&lt;/strong&gt; by Bavid H. Hoover and Adewale Oshineye,
in order to become a journeyman one must learn to explain their craft to
others. This is one apprentices effort to learn these skills.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About Me</title>
      <link>/about-me/</link>
      <pubDate>Tue, 11 Oct 2016 21:59:47 +1100</pubDate>
      
      <guid>/about-me/</guid>
      <description>&lt;p&gt;Hello people, I am &lt;strong&gt;Tobin Harding&lt;/strong&gt;. I code in the Linux environment. I like
command line interfaces and statically typed languages. When I am trying to
relax I listen to classical music, when eating jazz, and when getting excitable
I like to listen to techno.  I like learning things, mostly computer related
things but also violin. For health and giggles I surf, do yoga, ferment, and
grow vegetables. I am an apprentice programmer, my primary language is Go.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>